<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flip 7</title>
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/png" href="assets/favicon.png">
    <link rel="apple-touch-icon" href="assets/Flip7%20Logo.webp">
    <meta name="apple-mobile-web-app-title" content="Flip 7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1625">
    <meta name="description" content="Play Flip 7 card game online with friends">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <!-- Premium Effects Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.2/anime.min.js"></script>
    <!-- Chart.js for Stats Dashboard -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --primary: #8B5CF6;
            --primary-light: #A78BFA;
            --primary-dark: #7C3AED;
            --accent: #C084FC;
            --bg-gradient: linear-gradient(135deg, #1a1625 0%, #2d1f47 50%, #1a1625 100%);
            --glass-bg: rgba(255, 255, 255, 0.08);
            --glass-border: rgba(255, 255, 255, 0.15);
            --glass-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            --text: #F8FAFC;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --success: #10B981;
            --danger: #F43F5E;
            --warning: #F59E0B;
            --freeze: #38bdf8;
            --card-gradient: linear-gradient(145deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.02));
        }

        html {
            background-color: #1a1625;
            /* Fix for Safari white background on elastic scroll */
            scrollbar-gutter: stable;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-gradient);
            min-height: 100vh;
            min-height: 100dvh;
            /* Dynamic Viewport Height for mobile browsers */
            color: var(--text);
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle at 30% 20%, rgba(139, 92, 246, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 70% 80%, rgba(192, 132, 252, 0.1) 0%, transparent 50%);
            z-index: -1;
            animation: float 20s ease-in-out infinite;
        }

        @keyframes float {

            0%,
            100% {
                transform: translate(0, 0) rotate(0deg);
            }

            50% {
                transform: translate(-2%, 2%) rotate(2deg);
            }
        }

        .glass {
            background: var(--glass-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            box-shadow: var(--glass-shadow);
        }

        .header {
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--glass-border);
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            z-index: 50;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary-light), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .game-info {
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
            justify-content: center;
        }

        .badge {
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.3), rgba(168, 85, 247, 0.2));
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 6px 14px;
            border-radius: 30px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.2);
        }

        .badge strong {
            color: #fbbf24;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        /* Glassmorphism Score Badge */
        .badge-score {
            background: linear-gradient(135deg, rgba(251, 191, 36, 0.2), rgba(245, 158, 11, 0.1));
            border: 1px solid rgba(251, 191, 36, 0.4);
            color: #fbbf24;
            font-weight: 800;
            box-shadow: 0 0 15px rgba(251, 191, 36, 0.15);
            padding: 4px 10px;
            border-radius: 20px;
            text-shadow: 0 0 8px rgba(251, 191, 36, 0.3);
            letter-spacing: 0.5px;
        }

        /* Hit/Stay Buttons Icons */
        .btn svg {
            width: 20px;
            height: 20px;
            margin-right: 8px;
            fill: white;
        }

        /* SIDEBARS */
        .sidebar {
            position: fixed;
            top: 45%;
            height: 70vh;
            width: 70vw;
            max-width: 80%;
            background: rgba(26, 22, 37, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            z-index: 2000;
            transition: transform 0.3s ease-out;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            overflow: visible;
            /* Allow tab to hang out */
        }

        .sidebar-content {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            /* Scrollbar styling */
            scrollbar-width: thin;
        }

        .sidebar.left {
            left: 0;
            transform: translateY(-50%) translateX(-100%);
            /* Completely hidden except tab */
            border-top-right-radius: 20px;
            border-bottom-right-radius: 20px;
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        .sidebar.right {
            right: 0;
            transform: translateY(-50%) translateX(100%);
            /* Completely hidden except tab */
            border-top-left-radius: 20px;
            border-bottom-left-radius: 20px;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .sidebar.active {
            transform: translateY(-50%) translateX(0) !important;
        }

        .sidebar-tab {
            position: absolute;
            top: 10%;
            width: 60px;
            height: 60px;
            background: rgba(26, 22, 37, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            z-index: 1999;
            transition: all 0.2s ease-out;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            color: rgba(255, 255, 255, 0.8);
        }


        .sidebar-tab.left {
            right: -59px;
            /* 60px width - 1px overlap */
            left: auto;
            border-radius: 0 16px 16px 0;
            border-left: none;
        }

        .sidebar-tab.right {
            left: -59px;
            /* 60px width - 1px overlap */
            right: auto;
            border-radius: 16px 0 0 16px;
            border-right: none;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            /* Newest (first in array) at top */
            gap: 8px;
            margin-top: 15px;
        }

        .history-item {
            font-size: 13px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid var(--primary);
            color: var(--text-secondary);
            animation: slideIn 0.3s ease-out;
        }

        .badge-score {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fbbf24;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 700;
            margin-left: 8px;
            display: inline-block;
        }

        /* Bust Overlay Static State */
        .bust-overlay.static {
            animation: none;
            opacity: 1;
            transform: rotate(-5deg);
        }

        /* Real Fly-in from Deck */
        .card.fly-in {
            animation: flyFromDeck 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
            animation-play-state: paused;
            /* Wait for JS to calculate position */
            transform-origin: center center;
            z-index: 100;
            /* Fly above others */
        }

        @keyframes flyFromDeck {
            0% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0.2) rotate(180deg);
            }

            20% {
                opacity: 1;
            }

            100% {
                opacity: 1;
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
        }

        .leaderboard-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 14px;
        }

        #btnRules {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        #btnRules:hover {
            background: var(--primary);
            border-color: var(--primary);
        }

        #btnRules svg {
            width: 20px;
            height: 20px;
            fill: var(--text);
        }

        .lobby {
            max-width: 480px;
            margin: 40px auto;
            padding: 30px;
            text-align: center;
        }

        .lobby h2 {
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #fff, var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .lobby input {
            width: 100%;
            padding: 16px 20px;
            margin: 12px 0;
            border: 1px solid var(--glass-border);
            border-radius: 14px;
            font-size: 16px;
            background: rgba(0, 0, 0, 0.3);
            color: var(--text);
            backdrop-filter: blur(10px);
        }

        .lobby input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .btn {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border: none;
            padding: 16px 24px;
            border-radius: 14px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin: 6px;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.4);
        }

        .btn:active {
            transform: scale(0.98);
        }

        /* 3D Button Effects */
        /* Flat Button Effects (formerly 3D) */
        .btn-3d {
            position: relative;
            transform: translateY(0);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            /* Soft shadow only */
            transition: all 0.2s ease;
        }

        .btn-3d:hover {
            transform: translateY(-2px);
            /* Slight lift */
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        .btn-3d:active,
        .btn-3d.clicked {
            transform: scale(0.95);
            /* Simple shrink */
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        }

        .btn-carta {
            background: linear-gradient(135deg, #22c55e, #16a34a);
        }

        .btn-stop {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }

        .btn:disabled {
            background: rgba(255, 255, 255, 0.15) !important;
            box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2) !important;
            cursor: not-allowed;
            opacity: 0.6;
            filter: grayscale(80%);
            transform: translateY(0) !important;
        }

        @keyframes floatUp {
            0% {
                transform: translateY(0) scale(0.5);
                opacity: 0;
            }

            20% {
                transform: translateY(-20px) scale(1.2);
                opacity: 1;
            }

            80% {
                transform: translateY(-80px) scale(1);
                opacity: 1;
            }

            100% {
                transform: translateY(-100px) scale(0.8);
                opacity: 0;
            }
        }

        @keyframes popIn {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }

            60% {
                transform: translate(-50%, -50%) scale(1.3);
                opacity: 1;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes fadePop {
            0% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.5);
            }

            15% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.1);
            }

            30% {
                transform: translate(-50%, -50%) scale(1);
            }

            85% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
        }

        @keyframes scaleIn {
            0% {
                transform: scale(0);
                opacity: 0;
            }

            60% {
                transform: scale(1.1);
                opacity: 1;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        @keyframes bounceEnter {
            0% {
                transform: scale(0);
            }

            60% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
            }
        }

        .card.bounce {
            animation: bounceEnter 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) both !important;
        }

        .card.shiny {
            overflow: hidden;
        }

        .card.shiny::after {
            content: "";
            position: absolute;
            top: 0;
            left: -150%;
            width: 200%;
            height: 100%;
            background: linear-gradient(115deg, transparent 30%, rgba(255, 255, 255, 0.6) 45%, rgba(255, 255, 255, 0.0) 60%);
            transform: skewX(-20deg);
            animation: shine 3s infinite linear;
            pointer-events: none;
            z-index: 5;
        }

        @keyframes shine {
            0% {
                left: -150%;
            }

            20% {
                left: 150%;
            }

            /* Fast pass */
            100% {
                left: 150%;
            }

            /* Wait */
        }

        .smoke-particle {
            position: absolute;
            pointer-events: none;
            z-index: 2000;
            background: radial-gradient(circle, rgba(220, 220, 225, 0.9) 0%, rgba(150, 150, 160, 0) 70%);
            filter: blur(8px);
            border-radius: 50%;
            animation: riseFade 2.5s ease-out forwards;
        }

        @keyframes riseFade {
            0% {
                transform: translate(-50%, -50%) scale(0.5);
                opacity: 0.8;
            }

            100% {
                transform: translate(-50%, -200px) scale(3);
                opacity: 0;
            }
        }

        .btn.btn-cooldown {
            cursor: wait;
            opacity: 0.9;
            filter: brightness(1.1);
        }

        /* Ensure image buttons are centered */
        .btn-carta,
        .btn-stop {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            /* Adjust padding for images */
        }


        .btn-secondary {
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary-light);
            box-shadow: none;
        }

        .player-item {
            padding: 12px 16px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            margin: 8px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .leaderboard-row,
        .history-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            border: 1px solid rgba(255, 255, 255, 0.05);
            transition: transform 0.2s, background 0.2s;
        }

        .leaderboard-row:hover,
        .history-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(2px);
        }

        .room-link {
            background: rgba(0, 0, 0, 0.3);
            padding: 16px;
            border-radius: 12px;
            border: 1px solid var(--glass-border);
            margin: 20px 0;
            word-break: break-all;
            font-size: 13px;
        }

        .room-link a {
            color: var(--accent);
            text-decoration: none;
        }

        #qrcode-container {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            flex-direction: column;
            align-items: center;
        }

        #qrcode {
            padding: 10px;
            background: white;
            border-radius: 12px;
            margin-bottom: 5px;
            width: fit-content;
        }

        .game-container {
            display: none;
            padding: 20px;
            min-height: calc(100vh - 70px);
            padding-bottom: 120px;
        }

        .game-container.active {
            display: block;
        }

        .scoreboard {
            padding: 16px;
            margin-bottom: 20px;
        }

        .scoreboard h3 {
            font-size: 16px;
            margin-bottom: 12px;
            color: var(--accent);
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 10px 14px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin: 4px 0;
            border: 1px solid transparent;
            font-size: 14px;
        }

        .score-row.active {
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(139, 92, 246, 0.2);
        }

        .score-row.bust {
            opacity: 0.5;
            text-decoration: line-through;
        }

        .score-row.stayed {
            border-color: var(--success);
        }

        .deck-area {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 24px 0;
            align-items: center;
        }

        .deck {
            width: 90px;
            height: 126px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border-radius: 14px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            box-shadow: 0 10px 30px rgba(139, 92, 246, 0.4);
            position: relative;
        }

        .deck-count {
            font-size: 28px;
            font-weight: 700;
        }

        .last-card {
            width: 90px;
            height: 126px;
            border: 2px dashed var(--glass-border);
            border-radius: 14px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 11px;
            text-align: center;
            padding: 8px;
        }

        /* CARD VISUALS */
        .card {
            width: 60px;
            height: 88px;
            background: var(--card-gradient);
            backdrop-filter: blur(10px);
            /* border: 1px solid var(--glass-border);  NO BORDI */
            border-radius: 10px;
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 2px;
            /*4 era troppo */
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }

        /* Image support */
        .card-img {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            /* Contain to see whole card, or cover */
            object-fit: cover;
            z-index: 10;
        }

        .card-content {
            z-index: 1;
            display: flex;
            flex-direction: col;
            align-items: center;
        }

        .card.action {
            background: linear-gradient(135deg, rgba(244, 63, 94, 0.2), rgba(244, 63, 94, 0.05));
        }

        .card.action .card-value {
            font-size: 18px;
        }

        .card.modifier {
            /* border-color: #3B82F6; NO BORDI */
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.2), rgba(59, 130, 246, 0.05));
        }

        .players-area {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .player-zone {
            padding: 16px;
            transition: all 0.3s ease;
            position: relative;
            border-radius: 16px;
        }

        .player-zone.my-zone {
            border-color: var(--primary-light);
        }


        .player-zone.current-turn {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.4);
        }

        .player-zone.bust {
            opacity: 0.8;
            /* Slightly more visible than 0.5 */
            border-color: var(--danger);
        }

        /* Grayscale only non-bust-cause cards */
        .player-zone.bust .card:not(.bust-cause) {
            filter: grayscale(100%) opacity(0.6);
            transform: scale(0.95);
        }

        .player-zone.bust .card.bust-cause {
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(244, 63, 94, 0.6);
            z-index: 10;
            border: 2px solid var(--danger);
        }

        .player-zone.stayed {
            border-color: var(--success);
        }

        /* Visual Effects */
        .player-zone.frozen {
            border-color: var(--freeze);
            box-shadow: 0 0 25px rgba(56, 189, 248, 0.4);
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.1), transparent);
        }

        .player-zone.frozen::after {
            display: none;
        }


        .player-zone.flip3 {
            border-color: var(--warning);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
        }

        .player-zone.flip3::after {
            display: none;
        }

        .player-zone.bonus-sc {
            border-color: #F87171;
            /* Red-400 */
            box-shadow: 0 0 15px rgba(248, 113, 113, 0.3);
        }

        .player-zone.bonus-sc::after {
            display: none;
        }

        /* ========== DYNAMIC LAYOUT ZONES ========== */

        /* Active player zone (under deck) */
        .active-player-zone {
            margin: 16px auto;
            max-width: 420px;
            min-height: 0;
            padding: 0;
            border-radius: 16px;
            transition: all 0.3s ease;
        }

        .active-player-zone:empty {
            display: none !important;
        }

        .active-player-zone .player-zone {
            margin: 0;
            border-radius: 16px;
            border: 2px solid var(--primary);
            box-shadow: 0 0 20px rgba(139, 92, 246, 0.3);
        }

        /* Action target zone (dual display during Freeze/Flip3) */
        .action-target-zone {
            margin: 8px auto 16px;
            max-width: 420px;
            padding: 0;
            border-radius: 16px;
            border: 2px solid var(--warning);
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
        }

        .action-target-zone .player-zone {
            margin: 0;
            border-radius: 14px;
        }

        /* My hand zone (inside controls, always visible) */
        .my-hand-zone {
            width: 100%;
            margin-bottom: 12px;
        }

        .my-hand-zone:empty {
            display: none;
        }

        .my-hand-zone .player-zone {
            margin: 0;
            border-radius: 16px 16px 8px 8px;
            /* background: rgba(139, 92, 246, 0.08); teniamo zona minimal! */
        }

        /* Controls restructured for column layout */
        #controls {
            display: flex;
            flex-direction: column;
            padding: 12px;
            /* padding-top: 0; brutto, non lasciava un po' di bordo!*/
        }

        .buttons-row {
            display: flex;
            justify-content: space-between;
            gap: 8px;
            align-items: stretch;
        }

        /* ========== BROADCAST TOASTS ========== */
        .broadcast-toast {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 5000;
            padding: 16px 24px;
            border-radius: 16px;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            display: flex;
            align-items: center;
            justify-content: center;
            /* Center content */
            gap: 12px;
            font-weight: 600;
            font-size: 15px;
            color: white;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            animation: toastSlideIn 0.4s ease-out;
            width: 70vw;
            /* Fixed width as requested */
            max-width: 90vw;
        }

        .broadcast-toast.freeze {
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.4), rgba(14, 165, 233, 0.4));
            border: 1px solid rgba(56, 189, 248, 0.3);
        }

        .broadcast-toast.flip3 {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.4), rgba(234, 88, 12, 0.4));
            border: 1px solid rgba(245, 158, 11, 0.3);
        }

        .broadcast-toast.second-chance {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.4), rgba(239, 68, 68, 0.4));
            border: 1px solid rgba(248, 113, 113, 0.3);
        }

        @keyframes toastSlideIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-30px) scale(0.9);
            }

            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }
        }

        @keyframes toastSlideOut {
            from {
                opacity: 1;
                transform: translateX(-50%) translateY(0) scale(1);
            }

            to {
                opacity: 0;
                transform: translateX(-50%) translateY(-20px) scale(0.9);
            }
        }

        /* ========== FLOATING REACTIONS ========== */
        .floating-reaction {
            position: fixed;
            right: 16px;
            padding: 10px 16px;
            border-radius: 12px;
            background: var(--glass-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            animation: reactionSlideIn 0.3s ease-out;
            z-index: 4000;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
        }

        @keyframes reactionSlideIn {
            from {
                opacity: 0;
                transform: translateX(100px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }


        /* SC Burn Animation */
        .card.burning {
            animation: burnCard 2s forwards !important;
        }

        @keyframes burnCard {
            0% {
                transform: scale(1);
                filter: brightness(1);
            }

            30% {
                transform: scale(1.1);
                filter: brightness(1.5) sepia(1) saturate(3);
                box-shadow: 0 0 30px #ff6b00, 0 0 60px #ff3300;
            }

            50% {
                transform: scale(1.05);
                filter: brightness(2) sepia(1) saturate(4);
                box-shadow: 0 0 50px #ff6b00, 0 0 80px #ff0000;
            }

            100% {
                transform: scale(0) rotate(45deg);
                opacity: 0;
                filter: brightness(3);
            }
        }

        /* Enhanced Freeze Effect */
        .player-zone.frozen {
            background: linear-gradient(135deg, rgba(56, 189, 248, 0.2), rgba(14, 165, 233, 0.15)) !important;
            box-shadow: 0 0 30px rgba(56, 189, 248, 0.5), inset 0 0 20px rgba(56, 189, 248, 0.2) !important;
            border: 2px solid rgba(56, 189, 248, 0.6) !important;
            border-radius: 20px;
            animation: freezePulse 2s infinite;
        }

        .player-zone.frozen::before {
            content: '❄️';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 32px;
            font-weight: 900;
            color: #38bdf8;
            text-shadow: 0 0 20px #0ea5e9, 0 0 40px #38bdf8;
            z-index: 100;
            animation: iceFloat 1.5s ease-in-out infinite;
        }

        .player-zone.frozen .card {
            filter: brightness(0.7) saturate(0.5);
            opacity: 0.7;
        }

        @keyframes freezePulse {

            0%,
            100% {
                box-shadow: 0 0 25px rgba(56, 189, 248, 0.4);
            }

            50% {
                box-shadow: 0 0 45px rgba(56, 189, 248, 0.7), inset 0 0 30px rgba(56, 189, 248, 0.15);
            }
        }

        @keyframes iceFloat {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -55%) scale(1.05);
            }
        }

        /* Block UI during animations */
        body.animation-blocked .controls button {
            pointer-events: none;
            opacity: 0.5;
        }

        body.animation-blocked::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 999;
            pointer-events: none;
        }

        /* Overrides if multiple statuses? 
           We can stack them top-right, but simple absolute positioning might overlap. 
           Let's just trust that states are mutually exclusive mostly or one overrides another. 
        */

        .player-zone.bust-anim {
            animation: shake 0.4s ease-in-out both;
            border-color: var(--danger);
            box-shadow: 0 0 30px rgba(244, 63, 94, 0.6);
        }

        .card.bust-card {
            border-color: var(--danger) !important;
            box-shadow: 0 0 15px var(--danger);
            animation: glow 1s infinite alternate;
        }

        .player-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-name {
            font-weight: 600;
            font-size: 15px;
        }

        .player-points {
            font-size: 20px;
            font-weight: 700;
            color: var(--accent);
        }

        .player-cards {
            /* min-height: 96px; lasciamo che si adatti da solo*/
            display: flex;
            flex-wrap: wrap;
            /* gap: 4px; può non servire*/
        }

        /* Modifiers Row - below numbers */
        /* Modifiers Row - below numbers */
        .modifiers-row {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            /* Positive gap to ensure visibility */
            margin-top: 8px;
            min-height: 40px;
            padding-top: 5px;
        }

        .modifiers-row .card {
            transform: scale(1);
            /* Slightly larger */
            transform-origin: top center;
            /* Slight overlap */
            transition: all 0.3s ease;
        }

        .modifiers-row .card:hover {
            transform: scale(1) translateY(-10px);
            z-index: 100 !important;
            margin-right: 0;
        }

        .modifiers-row {
            position: relative;
            z-index: 50;
        }

        .modifiers-row .card {
            display: inline-block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }

        /* Stayed (player stopped) indicator */
        .player-zone.stayed {
            border-color: rgba(59, 246, 87, 0.5) !important;
            box-shadow: 0 0 15px rgba(59, 246, 87, 0.3), inset 0 0 20px rgba(59, 246, 87, 0.1);
        }

        .badge-stayed {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            font-size: 12px;
        }

        /* Bust Overlay */
        .bust-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 22, 37, 0.85);
            /* Slightly darker */
            backdrop-filter: blur(8px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: 900;
            color: var(--danger);
            text-shadow: 0 0 30px rgba(244, 63, 94, 0.8);
            border-radius: 20px;
            animation: bustEntrance 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) both, pulseText 1s ease-in-out 3, bustFadeOut 0.5s ease 2.5s forwards;
            z-index: 200;
            /* Higher than cards */
            letter-spacing: 4px;
            transform: rotate(-5deg);
            pointer-events: none;
            /* Let clicks pass through if needed */
        }

        @keyframes bustEntrance {
            from {
                opacity: 0;
                transform: scale(0.5) rotate(-15deg);
            }

            to {
                opacity: 1;
                transform: scale(1) rotate(-5deg);
            }
        }

        @keyframes pulseText {

            0%,
            100% {
                transform: scale(1) rotate(-5deg);
                text-shadow: 0 0 20px var(--danger);
            }

            50% {
                transform: scale(1.1) rotate(-5deg);
                text-shadow: 0 0 50px var(--danger), 0 0 80px red;
            }
        }

        @keyframes bustFadeOut {
            to {
                opacity: 0;
                visibility: hidden;
            }
        }

        .card.bust-cause {
            border: 4px solid var(--danger) !important;
            box-shadow: 0 0 30px var(--danger);
            animation: glowRed 2s infinite alternate;
            z-index: 150;
        }

        .card.bust-shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes glowRed {
            from {
                box-shadow: 0 0 10px var(--danger);
            }

            to {
                box-shadow: 0 0 40px var(--danger);
            }
        }

        /* Enhanced Badges */
        .badge-sc {
            background: linear-gradient(135deg, #F87171, #DC2626);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(248, 113, 113, 0.5);
            animation: pulseSubtle 3s infinite;
        }

        .badge-frozen {
            background: linear-gradient(135deg, #38BDF8, #0EA5E9);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.6);
        }

        @keyframes pulseSubtle {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(248, 113, 113, 0.5);
            }

            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(248, 113, 113, 0.8);
            }
        }


        .controls .btn {
            /* min-width: 140px; Causa problemi e allunga più del necessario i bottoni */
            font-size: 18px;
            padding: 18px 36px;
        }

        .btn-hit {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
        }

        .btn-stay {
            background: linear-gradient(135deg, var(--success), #059669);
        }

        @media (max-width: 640px) {
            .controls {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                z-index: 100;
                background: rgba(26, 22, 37, 0.95);
                backdrop-filter: blur(20px);
                border-top: 1px solid var(--glass-border);
                padding: 12px 16px;
                margin: 0;
                border-radius: 20px 20px 0 0;
                display: flex;
                gap: 12px;
                box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.3);
            }

            .controls .btn {
                flex: 1;
                padding: 16px;
                font-size: 18px;
                margin: 0;
            }

            .header {
                padding: 10px 16px;
            }

            .badge {
                display: none;
            }

            .badge#badgeDealer {
                display: inline-block;
            }

            .lobby {
                margin: 20px 16px;
                padding: 24px;
            }

            .players-area {
                grid-template-columns: 1fr;
            }

            .deck-area {
                gap: 20px;
                margin: 16px 0;
            }

            .game-container {
                padding: 16px;
                padding-bottom: 100px;
            }
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            padding: 24px;
            max-width: 500px;
            width: 100%;
            max-height: 85vh;
            overflow-y: auto;
            text-align: left;
        }

        .modal h3 {
            margin-bottom: 20px;
            color: var(--accent);
            font-size: 22px;
        }

        .target-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            margin: 8px 0;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: var(--text);
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .target-item:hover {
            border-color: var(--primary);
            background: rgba(139, 92, 246, 0.15);
            transform: translateX(5px);
        }

        .target-item.high-risk {
            border-color: rgba(239, 68, 68, 0.4);
            background: rgba(239, 68, 68, 0.1);
            box-shadow: 0 0 10px rgba(239, 68, 68, 0.1);
        }

        .target-item.high-risk:hover {
            border-color: rgba(239, 68, 68, 0.8);
            background: rgba(239, 68, 68, 0.2);
            box-shadow: 0 0 15px rgba(239, 68, 68, 0.2);
        }

        @keyframes slideIn {
            from {
                transform: translateX(-30px) scale(0.9);
                opacity: 0;
            }

            to {
                transform: translateX(0) scale(1);
                opacity: 1;
            }
        }

        /* Card Flying Animation */
        .card.fly-in {
            animation: flyIn 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) forwards !important;
            z-index: 100;
        }

        @keyframes flyIn {
            from {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(0.5) rotate(180deg);
            }

            to {
                opacity: 1;
                transform: translate(0, 0) scale(1) rotate(0deg);
            }
        }

        /* Fix Z-Indices for Modals/Overlays to be above Sidebars (2000) */
        .modal,
        #endGameOverlay,
        #flip7Overlay,
        #recapOverlay {
            z-index: 3000 !important;
        }



        @keyframes shake {

            0%,
            100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-5px);
            }

            75% {
                transform: translateX(5px);
            }
        }

        @keyframes glow {

            0%,
            100% {
                box-shadow: 0 0 20px var(--primary);
            }

            50% {
                box-shadow: 0 0 50px var(--primary), 0 0 80px var(--accent);
            }
        }

        .card.new {
            animation: slideIn 0.3s ease-out forwards;
        }

        .shake {
            animation: shake 0.05s linear 4;
        }

        .flip7-glow {
            animation: glow 0.5s ease-in-out 4;
        }

        @keyframes flyInAnim {
            0% {
                transform: translate(var(--tx), var(--ty)) scale(0.5);
                opacity: 0.5;
            }

            100% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
        }

        @keyframes riffleLeft {
            0% {
                transform: translateX(0) rotate(0deg) translateZ(0);
            }

            20% {
                transform: translateX(-60px) rotate(-15deg) translateZ(50px);
            }

            80% {
                transform: translateX(0) rotate(0deg) translateZ(0);
            }

            100% {
                transform: translateX(0) rotate(0deg) translateZ(0);
            }
        }

        @keyframes riffleRight {
            0% {
                transform: translateX(0) rotate(0deg) translateZ(0);
            }

            20% {
                transform: translateX(60px) rotate(15deg) translateZ(50px);
            }

            80% {
                transform: translateX(0) rotate(0deg) translateZ(0);
            }

            100% {
                transform: translateX(0) rotate(0deg) translateZ(0);
            }
        }

        @keyframes riffleMerge {

            0%,
            100% {
                transform: translateZ(0) scale(1);
            }

            50% {
                transform: translateZ(100px) scale(1.05);
                filter: brightness(1.2) drop-shadow(0 0 20px rgba(251, 191, 36, 0.5));
            }
        }

        .deck.shuffling {
            position: relative;
            transform-style: preserve-3d;
            perspective: 1000px;
            animation: riffleMerge 1.2s ease-in-out infinite;
        }

        .deck.shuffling::before,
        .deck.shuffling::after {
            content: '';
            position: absolute;
            inset: 0;
            background: url('assets/cards/back.webp');
            background-size: cover;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            z-index: 5;
        }

        .deck.shuffling::before {
            animation: riffleLeft 1.2s ease-in-out infinite;
        }

        .deck.shuffling::after {
            animation: riffleRight 1.2s ease-in-out infinite;
        }

        .deck.shuffling #deckLayers {
            opacity: 0.3;
            transition: opacity 0.3s;
        }

        .fly-in {
            animation: flyInAnim 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
            z-index: 100;
            /* Ensure flying card is on top */
        }

        #customToast {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 90%;
            max-width: 400px;
            background: rgba(26, 22, 37, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 16px 28px;
            border-radius: 16px;
            color: white;
            font-weight: 600;
            font-size: 16px;
            box-shadow: 0 15px 50px rgba(0, 0, 0, 0.5);
            z-index: 6000;
            opacity: 0;
            pointer-events: none;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-align: center;
        }

        #customToast.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        /* Recap Overlay */
        #recapOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(8px);
            z-index: 1000;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        #recapOverlay.active {
            display: flex;
            animation: fadeIn 0.4s ease;
        }

        .recap-card {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            color: white;
            width: 80%;
            max-width: 400px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
            /* Removed opacity:0 and transform - table shows immediately */
        }

        .recap-card.show {
            transform: translateY(0);
            opacity: 1;
        }

        .recap-name {
            font-size: 28px;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .recap-score {
            font-size: 56px;
            font-weight: 800;
            color: #fbbf24;
            margin: 10px 0;
            text-shadow: 0 0 20px rgba(251, 191, 36, 0.5);
        }

        .recap-stat {
            font-size: 16px;
            opacity: 0.8;
            margin: 5px 0;
        }

        .recap-badge {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            margin-top: 15px;
            font-size: 14px;
        }

        .badge-bust {
            background: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            border: 1px solid #ef4444;
        }

        .badge-success {
            background: rgba(34, 197, 94, 0.3);
            color: #86efac;
            border: 1px solid #22c55e;
        }

        .badge-flip7 {
            background: rgba(168, 85, 247, 0.3);
            color: #d8b4fe;
            border: 1px solid #a855f7;
            box-shadow: 0 0 15px #a855f7;
        }

        @keyframes fadeIn {
            from {
                opacity: 0
            }

            to {
                opacity: 1
            }
        }

        /* Action Card Splash */
        #cardSplash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            z-index: 1500;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }

        #cardSplash.active {
            display: flex;
            animation: fadeIn 0.3s ease;
        }

        .splash-title {
            font-size: 32px;
            font-weight: 800;
            color: white;
            text-shadow: 0 0 30px currentColor, 0 0 60px currentColor;
            margin-bottom: 20px;
            animation: pulseGlow 1s ease infinite alternate;
        }

        .splash-title.freeze {
            color: #3b82f6;
        }

        .splash-title.flip3 {
            color: #f59e0b;
        }

        .splash-title.second_chance {
            color: #ef4444;
        }

        @keyframes pulseGlow {
            from {
                transform: scale(1);
                opacity: 0.8;
            }

            to {
                transform: scale(1.05);
                opacity: 1;
            }
        }

        .splash-card {
            width: 120px;
            height: 168px;
            background: rgba(139, 92, 246, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 48px;
            box-shadow: 0 0 40px rgba(139, 92, 246, 0.5);
            animation: cardBounce 0.5s ease;
        }

        @keyframes cardBounce {
            0% {
                transform: scale(0.5) translateY(50px);
                opacity: 0;
            }

            70% {
                transform: scale(1.1) translateY(-10px);
            }

            100% {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }

        /* Bust Dimming */
        .player-zone.bust .card:not(.bust-cause) {
            filter: grayscale(100%) brightness(0.5);
            opacity: 0.6;
            transition: all 0.5s ease;
        }

        /* My Zone Enhanced */
        .player-zone.my-zone {
            grid-column: 1 / -1;
            width: 100%;
            margin: 0;
            transform: scale(1);
            /* border: 2px solid rgba(139, 92, 246, 0.5);
            background: rgba(139, 92, 246, 0.1); commentati per tenere la zona bottoni minimal */
            z-index: 10;
            order: -1;
            border-radius: 20px;
            /* Always first in flex container */
            padding: 5px;
            /* Reduced to 5px to maximize space */
        }

        /* Compact zones for other players */
        .player-zone:not(.my-zone) {
            opacity: 0.9;
            /* margin: 5px auto; occupa spazio! */
        }

        .player-zone:not(.my-zone) .card {
            width: 45px;
            height: 63px;
        }

        /* Mobile Optimizations */
        @media (max-width: 600px) {
            .header {
                flex-direction: row;
                gap: 6px;
                padding: 8px 10px;
                justify-content: space-between;
            }

            .header h1 {
                font-size: 0;
            }

            .header h1 img {
                height: 28px;
            }

            .game-info {
                display: flex;
                flex-direction: row;
                flex-wrap: wrap;
                gap: 3px;
                overflow: visible;
            }

            .badge {
                padding: 2px 5px;
                font-size: 8px;
                flex-shrink: 0;
            }

            /* Ensure game-info-bar is visible on mobile */
            .game-info-bar {
                display: flex !important;
                flex-wrap: wrap;
                gap: 5px;
                padding: 6px 10px !important;
            }

            .game-info-bar .badge {
                font-size: 9px;
                padding: 3px 8px;
            }

            .deck-area {
                margin: 10px auto;
            }

            .deck {
                width: 60px;
                height: 90px;
            }

            .deck-count {
                font-size: 18px;
            }

            .player-zone {
                padding: 10px;
                width: 100%;
                max-width: none;
            }

            .player-zone.my-zone {
                transform: scale(1);
                width: 100%;
            }

            /* Removed .p-name::after rule to create custom badge */

            .round-score-glass {
                background: rgba(251, 191, 36, 0.15);
                border: 1px solid rgba(251, 191, 36, 0.3);
                color: #fbbf24;
                border-radius: 12px;
                padding: 2px 8px;
                font-weight: 700;
                font-size: 14px;
                box-shadow: 0 0 10px rgba(251, 191, 36, 0.1);
                transition: all 0.3s;
            }

            .modifiers-row {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                margin-top: 2px;
                justify-content: center;
            }

            /* Ensure my modifier cards are full size */
            .player-zone.my-zone .modifiers-row .card {
                width: 60px;
                height: 90px;
                transform: none;
            }

            .card-placeholder {
                border: 2px dashed rgba(255, 255, 255, 0.2);
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.1);
                box-sizing: border-box;
            }

            /* Dynamic sizing for My Zone main cards */
            .player-zone.my-zone .player-cards {
                display: flex;
                flex-wrap: wrap;
                gap: 3px;
                align-items: flex-start;
                /* Prevent vertical stretching */
            }

            .player-zone.my-zone .player-cards .card,
            .player-zone.my-zone .player-cards .card-placeholder {
                width: calc((100% - 18px) / 7);
                /* 7 cards, 6 gaps of 3px = 18px */
                height: auto;
                aspect-ratio: 2 / 3;
                flex: 0 0 auto;
                max-width: none;
                max-height: none;
                margin: 0;
                /* Override global card margin */
            }

            .p-badges .badge-score {
                display: none;
            }

            .controls {
                padding: 16px;
                /* Expanded padding */
                padding-bottom: 30px;
                /* Extra bottom padding for mobile safety */
            }

            .controls button {
                padding: 16px 24px;
                /* Larger buttons */
                font-size: 16px;
            }
        }

        /* Recap Table Styling */
        .recap-table {
            width: 100%;
            border-collapse: collapse;
            color: white;
            margin-top: 20px;
        }

        .recap-table th {
            text-align: left;
            padding: 10px;
            color: var(--text-secondary);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .recap-table td {
            padding: 12px 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .recap-row.winner {
            background: rgba(34, 197, 94, 0.1);
        }

        .recap-row.bust {
            color: var(--danger);
        }

        .recap-pts {
            font-weight: bold;
            font-size: 18px;
        }

        /* Stats Dashboard Bottom Sheet */
        #statsSheet {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 70vh;
            max-height: 600px;
            background: rgba(26, 22, 37, 0.95);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-top-left-radius: 24px;
            border-top-right-radius: 24px;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 1500;
            transform: translateY(110%);
            /* Increased offset for Safety */
            visibility: hidden;
            /* Hide completely when closed */
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1), visibility 0.4s;
            display: flex;
            flex-direction: column;
            box-shadow: 0 -10px 40px rgba(0, 0, 0, 0.5);
        }

        #statsSheet.open {
            transform: translateY(0);
            visibility: visible;
        }

        .stats-handle {
            width: 40px;
            height: 5px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
            margin: 12px auto 8px;
            cursor: grab;
        }

        .stats-header {
            padding: 0 20px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stats-header h3 {
            margin: 0;
            font-size: 18px;
            background: linear-gradient(135deg, #FF6B35, #fbbf24);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stats-close {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            color: white;
            font-size: 18px;
            cursor: pointer;
        }

        .stats-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }

        .chart-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chart-card h4 {
            margin: 0 0 12px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .chart-card canvas {
            max-height: 200px;
        }

        /* Stats Button */
        .btn-stats {
            background: rgba(255, 255, 255, 0.1) !important;
            backdrop-filter: blur(10px) !important;
            -webkit-backdrop-filter: blur(10px) !important;
            border: 1px solid rgba(255, 255, 255, 0.2) !important;
            color: white !important;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1) !important;
        }

        #sidebarLeaderboardContent {
            margin-top: 25px;
            /* Spacing from header */
        }

        /* Leaderboard Ranks */
        .leaderboard-row.rank-1 {
            border-color: #fbbf24 !important;
            /* Gold */
            background: linear-gradient(90deg, rgba(251, 191, 36, 0.15), transparent);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.2);
        }

        .leaderboard-row.rank-2 {
            border-color: #cbd5e1 !important;
            /* Silver */
            background: linear-gradient(90deg, rgba(203, 213, 225, 0.15), transparent);
            box-shadow: 0 4px 12px rgba(203, 213, 225, 0.2);
        }

        .leaderboard-row.rank-3 {
            border-color: #d1a684 !important;
            /* Bronze */
            background: linear-gradient(90deg, rgba(209, 166, 132, 0.15), transparent);
            box-shadow: 0 4px 12px rgba(209, 166, 132, 0.2);
        }

        .rank-text-1 {
            color: #fbbf24;
            font-weight: 800;
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
        }

        .rank-text-2 {
            color: #cbd5e1;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(203, 213, 225, 0.4);
        }

        .rank-text-3 {
            color: #d1a684;
            font-weight: 700;
            text-shadow: 0 0 8px rgba(209, 166, 132, 0.4);
        }

        /* End-game stats section */
        .endgame-stats {
            margin-top: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
        }

        @keyframes pulseRed {
            0% {
                box-shadow: 0 0 5px rgba(239, 68, 68, 0.4);
            }

            100% {
                box-shadow: 0 0 15px rgba(239, 68, 68, 0.8), 0 0 30px rgba(239, 68, 68, 0.4);
            }
        }


        .endgame-stats h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 20px;
            background: linear-gradient(135deg, #FF6B35, #fbbf24);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        @media (min-width: 768px) {
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .chart-card.full-width {
                grid-column: span 2;
            }
        }

        /* PWA Install Banner */
        .install-banner {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            background: rgba(30, 27, 46, 0.95);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 15px 20px;
            display: none;
            /* Hidden by default */
            align-items: center;
            justify-content: space-between;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
            z-index: 9999;
            animation: slideUp 0.6s cubic-bezier(0.16, 1, 0.3, 1);
        }

        .install-banner.visible {
            display: flex;
        }

        .install-img {
            width: 48px;
            height: 48px;
            border-radius: 12px;
            margin-right: 15px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        .install-text {
            flex: 1;
            font-size: 14px;
            color: #fff;
            line-height: 1.3;
        }

        .install-text strong {
            display: block;
            font-size: 16px;
            margin-bottom: 2px;
        }

        .install-btn {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 18px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 13px;
            cursor: pointer;
            margin-left: 10px;
            white-space: nowrap;
            box-shadow: 0 4px 15px rgba(139, 92, 246, 0.3);
            transition: transform 0.2s;
        }

        .install-btn:active {
            transform: scale(0.95);
        }

        .close-install {
            position: absolute;
            top: -10px;
            right: -10px;
            background: #2d2a40;
            color: #fff;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100px);
                opacity: 0;
            }

            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        /* iOS PWA Informational Modal */
        #iosPwaModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            z-index: 10000;
            display: none;
            align-items: flex-end;
            justify-content: center;
        }

        #iosPwaModal.active {
            display: flex;
        }

        .ios-pwa-content {
            width: 100%;
            max-width: 500px;
            background: #1e1b2e;
            border-top-left-radius: 30px;
            border-top-right-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 30px 25px 40px;
            text-align: center;
            animation: slideUp 0.5s cubic-bezier(0.16, 1, 0.3, 1);
        }
    </style>
</head>

<body>
    <header class="header">
        <h1 id="headerTitle" style="font-size:18px; font-weight:600; margin:0; cursor:pointer;"
            onclick="window.location.href = window.location.origin + window.location.pathname">Flip 7</h1>
        < !-- Game Status in Header (hidden by default, shown during game) -->
            <div id="headerGameStatus"
                style="display:none; align-items:center; gap:12px; background:rgba(139,92,246,0.2); padding:4px 12px; border-radius:20px; backdrop-filter:blur(10px); border:1px solid rgba(139,92,246,0.3);">
                <span style="font-size:12px; font-weight:600; color:#34d399;">🎯 <span
                        id="turnName">-</span></span><span style="font-size:12px; font-weight:600; color:#60a5fa;">Round
                    <span id="roundNum">1</span></span></div><button id="btnRules" title="Regole"><svg
                    viewBox="0 0 24 24">
                    <path
                        d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z" />
                </svg></button>
    </header>
    <div class="lobby glass" id="lobby"><img src="assets/Flip7 Logo.webp" alt="Flip 7"
            style="height:80px; margin-bottom:15px; cursor:pointer;"
            onclick="window.location.href = window.location.origin + window.location.pathname">
        <h2>Benvenuto !</h2>
        <p>Sfida i tuoi amici ! Il primo che arriva a 200 punti,
            vince ! 🏆</p><input type="text" id="nickname" placeholder="Il tuo nickname" maxlength="15">
        <div id="hostControls"><button class="btn" id="btnCreateRoom">Crea Stanza</button><button
                class="btn btn-secondary" id="btnShowJoin" style="margin-top:10px;">Unisciti a Stanza</button>
            <div id="joinCodeArea"
                style="display:none; margin-top:15px; border-top:1px solid rgba(255,255,255,0.1); padding-top:15px; width:100%">
                <input type="text" id="roomCodeInput" placeholder="Inserisci codice stanza..." maxlength="10"
                    style="margin-bottom:10px; text-transform:uppercase; text-align:center; letter-spacing:1px;"><button
                    class="btn btn-secondary" id="btnJoinRoom" style="width:100%">Unisciti</button></div>
        </div>
        <div id="roomInfo" style="display:none;">
            <div class="room-link">🔗 Link Stanza:<br><a href="#" id="roomLink" target="_blank"></a><br>
                <div id="qrcode-container">
                    <div id="qrcode"></div><span style="font-size:12px; color:var(--text-secondary)">Scansiona per
                        unirti</span>
                </div><button class="btn btn-secondary" style="margin-top:10px; padding:8px 16px; font-size:12px;"
                    onclick="copyRoomLink()">📋 Copia Link</button>
            </div>
            <div class="players-list" id="playersList"></div>
            <p id="lobbyStatusMsg" style="font-size:12px; color:var(--text-secondary); margin-top:10px">In attesa che
                l'host avvii la partita...</p>
            <button class="btn" id="btnStartGame" style="display:none;">🎮 Inizia Partita</button>
        </div>
    </div>
    <div class="game-container" id="gameContainer">
        < !-- Left Sidebar: Leaderboard -->
            <div id="leaderboardSidebar" class="sidebar left glass">
                <div class="sidebar-tab left glass" onclick="toggleSidebar('leaderboardSidebar')">🏆 </div>
                <div class="sidebar-content">
                    <h3>🏆 Classifica</h3><span
                        style="font-size:12px; color:var(--text-secondary); margin-bottom:15px">Obiettivo: 200
                        pts</span>
                    <div id="sidebarLeaderboardContent"></div><button class="btn btn-3d btn-stats" id="btnStats"
                        disabled aria-label="Statistiche"
                        style="width:60%; margin-top:20px; display:flex; align-items:center; justify-content:center; gap:10px; padding:12px; justify-self: center;"><span
                            style="font-size:20px;">📊</span><span
                            style="font-size:14px; font-weight:600;">Statistiche</span></button>
                </div>
            </div>
            < !-- Right Sidebar: History -->
                <div id="historySidebar" class="sidebar right glass">
                    <div class="sidebar-tab right glass" onclick="toggleSidebar('historySidebar')">📜 </div>
                    <div class="sidebar-content">
                        <h3>📜 Storico</h3><span
                            style="font-size:12px; color:var(--text-secondary); margin-bottom:15px">Cronologia
                            partite</span>
                        <div id="sidebarHistoryContent" class="history-list">
                            <div
                                style="text-align:center; padding:20px; color:var(--text-secondary); font-style:italic">
                                Nessuna azione ancora...</div>
                        </div>
                    </div>
                </div>
                <div class="deck-area"
                    style="display:flex; align-items:center; justify-content:center; gap:15px; margin:20px 0;">
                    < !-- Personal Score -->
                        <div class="glass"
                            style="padding:10px 16px; border-radius:16px; text-align:center; min-width: 70px;">
                            <div
                                style="font-size:9px; opacity:0.7; text-transform:uppercase; letter-spacing:1px; margin-bottom:2px;">
                                Punti</div>
                            <div style="font-size:22px; font-weight:800; color:#A78BFA; text-shadow:0 0 15px rgba(167, 139, 250, 0.4);"
                                id="personalTot">0</div>
                        </div>
                        < !-- Deck with layered cards -->
                            <div class="deck" id="deckContainer"
                                style="width:90px; height:126px; position:relative; transform-style:preserve-3d; transition:all 0.3s; cursor:default;">
                                < !-- Layered cards for depth effect -->
                                    <div id="deckLayers" style="position:absolute; inset:0;">
                                        <div class="deck-layer"
                                            style="position:absolute; top:0; left:0; width:100%; height:100%; transform:translateX(-4px) translateY(4px) rotate(-1deg);">
                                            <img src="assets/cards/back.webp"
                                                style="width:100%; height:100%; border-radius:12px; object-fit:cover; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">
                                        </div>
                                        <div class="deck-layer"
                                            style="position:absolute; top:0; left:0; width:100%; height:100%; transform:translateX(-2px) translateY(2px) rotate(-0.5deg);">
                                            <img src="assets/cards/back.webp"
                                                style="width:100%; height:100%; border-radius:12px; object-fit:cover; box-shadow: 0 2px 5px rgba(0,0,0,0.3);">
                                        </div>
                                        <div class="deck-layer"
                                            style="position:absolute; top:0; left:0; width:100%; height:100%; transform:translateX(0) translateY(0) rotate(0deg);">
                                            <img src="assets/cards/back.webp"
                                                style="width:100%; height:100%; border-radius:12px; object-fit:cover; box-shadow: 0 4px 15px rgba(0,0,0,0.4);">
                                        </div>
                                    </div>
                            </div>
                            < !-- Deck Count (right of deck) -->
                                <div class="glass"
                                    style="padding:10px 16px; border-radius:16px; text-align:center; min-width: 70px;">
                                    <div
                                        style="font-size:9px; opacity:0.7; text-transform:uppercase; letter-spacing:1px; margin-bottom:2px;">
                                        Carte</div>
                                    <div style="font-size:22px; font-weight:800; color:#fbbf24; text-shadow:0 0 15px rgba(251, 191, 36, 0.4);"
                                        id="deckCount">0</div>
                                </div>
                </div>
                < !-- Dynamic Zone: Active Player (shows current turn player if not me) -->
                    <div id="activePlayerZone" class="active-player-zone glass"></div>
                    < !-- Dynamic Zone: Action Target (shows during Freeze/Flip3 dual display) -->
                        <div id="actionTargetZone" class="action-target-zone glass" style="display:none;"></div>
                        < !-- Other players (excluding me and those shown above) -->
                            <div class="players-area" id="playersArea"></div>
                            < !-- Controls with MY HAND always visible -->
                                <div class="controls glass" id="controls" role="group" aria-label="Azioni gioco">
                                    < !-- My Hand Zone (always visible at bottom) -->
                                        <div id="myHandZone" class="my-hand-zone"></div>
                                        < !-- Buttons Row -->
                                            <div class="buttons-row"><button class="btn btn-3d btn-carta" id="btnHit"
                                                    disabled aria-label="Pesca una carta" style="flex:2;"><img
                                                        src="https://em-content.zobj.net/source/microsoft-teams/400/palm-up-hand_medium-light-skin-tone_1faf4-1f3fc_1f3fc.png"
                                                        alt="Carta"
                                                        style="height:40px; width:auto; pointer-events:none;"></button>
                                                <div
                                                    style="flex:1; position:relative; display:flex; align-items:center; justify-content:center;">
                                                    <button class="btn btn-3d btn-react" id="btnReact"
                                                        aria-label="Reazioni" disabled
                                                        style="width:100%; height:100%; padding:0; display:flex; align-items:center; justify-content:center; background:transparent; border:none; box-shadow:none; cursor:pointer; border-radius:50%;"><img
                                                            src="https://em-content.zobj.net/source/microsoft-teams/400/speech-balloon_1f4ac.png"
                                                            style="height:35px; filter:drop-shadow(0 4px 6px rgba(0,0,0,0.2)); transition:transform 0.2s;"></button>
                                                    <div id="reactionPicker" class="glass" style=" display: none;
 position: absolute;
        bottom: 85px;
        width: 95vw;
        max-height: 180px;
        overflow-y: auto;
        padding: 10px;
        display: grid;
        grid-template-columns: repeat(6, 1fr);
        z-index: 100;
        opacity: 0;
        transition: opacity 0.2s;
        ">
                                                        < !-- Filled by JS -->
                                                    </div>
                                                </div><button class="btn btn-3d btn-stop" id="btnStay" disabled
                                                    aria-label="Fermati" style="flex:2;">
                                                    < !-- FIX 6: Using Raising Hands APNG for Stay button --><img
                                                            src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Hand%20gestures/Raising%20Hands%20Medium-Light%20Skin%20Tone.png"
                                                            alt="Stop"
                                                            style="height:40px; width:auto; pointer-events:none;">
                                                </button>
                                            </div>
                                </div>
    </div>
    < !-- Stats Bottom Sheet -->
        <div id="statsSheet">
            <div class="stats-handle"></div>
            <div class="stats-header">
                <h3>📊 Statistiche Partita</h3><button class="stats-close" onclick="closeStatsSheet()">&times;
                </button>
            </div>
            <div class="stats-content">
                <div class="stats-grid">
                    <div class="chart-card full-width">
                        <h4>📈 Punteggio Cumulativo</h4><canvas id="chartLine"></canvas>
                    </div>
                    <div class="chart-card">
                        <h4>📊 Azioni per Giocatore</h4><canvas id="chartBar"></canvas>
                    </div>
                    <div class="chart-card">
                        <h4>🎯 Distribuzione Azioni</h4><canvas id="chartDonut"></canvas>
                    </div>
                    <div class="chart-card">
                        <h4>🔥 Carte vs Outcome</h4><canvas id="chartHeatmap"></canvas>
                    </div>
                    <div class="chart-card">
                        <h4>⭐ Performance Giocatori</h4><canvas id="chartRadar"></canvas>
                    </div>
                </div>
            </div>
        </div>
        <div class="modal" id="rulesModal">
            <div class="modal-content glass"
                style="width: 100%; max-width: 650px; height: 700px; max-height: 90vh; display:flex; flex-direction:column; padding: 0; background: rgba(20, 20, 30, 0.4); border: 1px solid rgba(255,255,255,0.15); box-shadow: 0 0 30px rgba(0,0,0,0.5);">
                <div
                    style="padding: 24px 24px 12px 24px; display:flex; justify-content:space-between; align-items:center; border-bottom: 1px solid rgba(255,255,255,0.1); flex-shrink:0;">
                    <h3
                        style="margin:0; font-size: 24px; font-weight: 800; background: linear-gradient(135deg, #fff, #a78bfa); -webkit-background-clip: text; background-clip: text; -webkit-text-fill-color: transparent; letter-spacing: -0.5px;">
                        📜 Regole del Gioco</h3><button
                        onclick="document.getElementById('rulesModal').classList.remove('active')"
                        style="background:rgba(255,255,255,0.1); border:none; width:36px; height:36px; border-radius:50%; color:white; font-size:22px; cursor:pointer; display:flex; align-items:center; justify-content:center; transition:all 0.2s;">&times;
                    </button>
                </div>
                <div class="rules-tabs" style="display:flex; gap:12px; padding: 18px 24px 8px 24px; flex-shrink:0;">
                    <button class="tab-btn active" onclick="switchTab('tab-general')">Generale</button><button
                        class="tab-btn" onclick="switchTab('tab-cards')">Carte</button><button class="tab-btn"
                        onclick="switchTab('tab-actions')">Azioni</button></div>
                <div class="rules-body" style="overflow-y:auto; padding: 10px 24px 24px 24px; flex:1;">
                    < !-- GENERAL TAB -->
                        <div id="tab-general" class="tab-content active">
                            <p
                                style="font-size:16px; line-height:1.7; margin-bottom:20px; color: rgba(255,255,255,0.9);">
                                <strong>Flip 7</strong>è un gioco ad alto rischio dove il tempismo è tutto. L'obiettivo
                                è
                                accumulare il punteggio più alto pescando dal mazzo,
                                ma la bramosia può essere fatale ! </p>
                            <div
                                style="background:rgba(244, 63, 94, 0.12); padding:20px; border-radius:16px; margin-bottom:20px; border:1px solid rgba(244, 63, 94, 0.25); display:flex; align-items:center; gap:20px;">
                                <img src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Smilies/Enraged%20Face.png"
                                    style="height:64px; filter: drop-shadow(0 0 10px rgba(244,63,94,0.4));"
                                    alt="Bust Icon">
                                <div><strong
                                        style="color:#f87171; display:block; margin-bottom:6px; font-size: 16px; text-transform:uppercase; letter-spacing:1px;">BUST
                                        (Sballare)</strong>
                                    <p style="font-size:14px; margin:0; opacity:0.85; line-height:1.5;">Se peschi una
                                        carta numero che <strong>è già presente</strong>nella tua mano corrente,
                                        sballi immediatamente. <br>Perdi tutti i punti del round e la tua manche termina
                                        qui. 😡 </p>
                                </div>
                            </div>
                            <div
                                style="background:linear-gradient(135deg, rgba(168, 85, 247, 0.15), rgba(139, 92, 246, 0.08)); padding:20px; border-radius:16px; margin-bottom:20px; border:1px solid rgba(168, 85, 247, 0.25); display:flex; gap:16px; align-items:center;">
                                <img src="assets/cards/action_flip3.webp"
                                    style="height:85px; filter:drop-shadow(0 4px 12px rgba(168,85,247,0.5)); transform:rotate(-4deg);">
                                <div><strong
                                        style="color:#c084fc; font-size: 16px; text-transform:uppercase; letter-spacing:1px;">FLIP
                                        7 BONUS (+15)</strong>
                                    <p style="font-size:14px; margin-top:6px; opacity:0.85; line-height:1.5;">Raccogli
                                        <strong>7 carte numeriche DIVERSE</strong>per ottenere un bonus istantaneo di 15
                                        punti. Se completi il Flip 7,
                                        il tuo turno finisce ma il tuo punteggio è al sicuro ! </p>
                                </div>
                            </div>
                            <h4 style="font-size: 16px; margin-bottom:12px; color: #fff;">Consigli Strategici:</h4>
                            <ul
                                style="padding-left:20px; font-size:14px; line-height:1.7; color: rgba(255,255,255,0.8); margin-bottom:10px;">
                                <li><strong>Probabilità:</strong>Il valore della carta indica quante copie esistono nel
                                    deck. Ci sono 12 carte "12",
                                    ma solo una carta "1" .</li>
                                <li><strong>Hit o Stay:</b>"Stay" salva il tuo punteggio corrente. "Hit" rischia tutto
                                        per la gloria. Non aver paura di fermarti !</li>
                                <li><strong>Osserva gli avversari:</strong>Le carte in gioco non possono essere pescate
                                    di nuovo finché non vengono rimescolate. Controlla il tavolo !</li>
                            </ul>
                        </div>
                        < !-- CARDS TAB -->
                            <div id="tab-cards" class="tab-content">
                                <div class="rules-section" style="margin-bottom:24px;">
                                    <h4
                                        style="color:#fbbf24; margin-bottom:12px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:8px; font-size:18px;">
                                        Carte Numero (0-12)</h4>
                                    <p style="font-size:15px; margin-bottom:15px; opacity:0.9;">Sono la linfa vitale del
                                        gioco. La somma dei loro valori determina il tuo punteggio finale.</p>
                                    <div
                                        style="display:flex; gap:15px; margin:20px 0; justify-content:center; flex-wrap:wrap;">
                                        <div style="text-align:center;"><img src="assets/cards/number_1.webp"
                                                style="height:90px; border-radius:8px; box-shadow:0 4px 10px rgba(0,0,0,0.4);"><span
                                                style="display:block; font-size:12px; margin-top:5px; color:#fbbf24;">Raro
                                                (1 copia)</span></div>
                                        <div style="text-align:center;"><img src="assets/cards/number_7.webp"
                                                style="height:90px; border-radius:8px; box-shadow:0 4px 10px rgba(0,0,0,0.4);"><span
                                                style="display:block; font-size:12px; margin-top:5px; color:#fbbf24;">Medio
                                                (7 copie)</span></div>
                                        <div style="text-align:center;"><img src="assets/cards/number_12.webp"
                                                style="height:90px; border-radius:8px; box-shadow:0 4px 10px rgba(0,0,0,0.4);"><span
                                                style="display:block; font-size:12px; margin-top:5px; color:#fbbf24;">Comune
                                                (12 copie)</span></div>
                                    </div>
                                    <div
                                        style="background:rgba(255,255,255,0.04); padding:15px; border-radius:12px; border:1px solid rgba(255,255,255,0.08);">
                                        <strong style="display:block; margin-bottom:6px; font-size:14px; color:#fff;">📊
                                            Distribuzione Deck</strong>
                                        <p style="font-size:13px; opacity:0.8; margin:0; line-height:1.6;">• Carte 0-12:
                                            Il numero di copie è pari al valore (tranne lo 0 che ha 1 copia).<br>• Più
                                            carte numeriche hai,
                                            più è probabile pescare un doppione.<br>• Carte 10,
                                            11 e 12 sono le più pericolose da "accumulare" . </p>
                                    </div>
                                </div>
                                <div class="rules-section">
                                    <h4
                                        style="color:#60a5fa; margin-bottom:12px; border-bottom:1px solid rgba(255,255,255,0.1); padding-bottom:8px; font-size:18px;">
                                        Modifier (Punti Extra)</h4>
                                    <div style="display:flex; gap:20px; margin:20px 0;">
                                        <div
                                            style="flex:1; text-align:center; background: rgba(255,255,255,0.03); padding: 15px; border-radius: 12px;">
                                            <img src="assets/cards/modifier_+6.webp"
                                                style="height:100px; margin-bottom:10px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));"><strong
                                                style="display:block; font-size:14px; color:#60a5fa;">Addizzionali</strong>
                                            <p style="font-size:12px; opacity:0.8; margin-top:5px;">Aggiungono punti
                                                fissi (+2, +4,
                                                +6) al totale senza rischio di Bust.</p>
                                        </div>
                                        <div
                                            style="flex:1; text-align:center; background: rgba(255,255,255,0.03); padding: 15px; border-radius: 12px;">
                                            <img src="assets/cards/modifier_x2.webp"
                                                style="height:100px; margin-bottom:10px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));"><strong
                                                style="display:block; font-size:14px; color:#60a5fa;">Moltiplicatori</strong>
                                            <p style="font-size:12px; opacity:0.8; margin-top:5px;">Raddoppiano la somma
                                                delle sole carte numeriche. Esponenziale !</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            < !-- ACTIONS TAB -->
                                <div id="tab-actions" class="tab-content">
                                    <p style="font-size:14px; margin-bottom:20px; opacity:0.9;">Le Carte Azione cambiano
                                        le sorti della partita. Usale per difenderti o ostacolare gli altri.</p>
                                    <div class="action-rule"
                                        style="margin-bottom:15px; background:linear-gradient(90deg, rgba(56, 189, 248, 0.15), transparent); border-radius:12px; padding:15px; border:1px solid rgba(56, 189, 248, 0.3); display:flex; gap:20px; align-items:center;">
                                        <img src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Smilies/Cold%20Face.png"
                                            style="height:50px; filter: drop-shadow(0 0 8px rgba(56,189,248,0.5));"
                                            alt="Freeze Icon">
                                        <div style="flex:1;">
                                            <div
                                                style="display:flex; justify-content:space-between; align-items:center;">
                                                <strong style="font-size:17px; color:#7dd3fc;">Freeze</strong><img
                                                    src="assets/cards/action_freeze.webp"
                                                    style="height:45px; border-radius:4px;"></div>
                                            <p style="font-size:13px; opacity:0.9; margin-top:6px; line-height:1.5;">
                                                Seleziona un avversario per "congelarlo" . Sarà costretto a fare
                                                <strong>Stay immediato</strong>,
                                                perdendo la possibilità di pescare ancora. </p>
                                        </div>
                                    </div>
                                    <div class="action-rule"
                                        style="margin-bottom:15px; background:linear-gradient(90deg, rgba(245, 158, 11, 0.15), transparent); border-radius:12px; padding:15px; border:1px solid rgba(245, 158, 11, 0.3); display:flex; gap:20px; align-items:center;">
                                        <img src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Travel%20and%20places/High%20Voltage.png"
                                            style="height:50px; filter: drop-shadow(0 0 8px rgba(245,158,11,0.5));"
                                            alt="Flip3 Icon">
                                        <div style="flex:1;">
                                            <div
                                                style="display:flex; justify-content:space-between; align-items:center;">
                                                <strong style="font-size:17px; color:#fcd34d;">Flip Three</strong><img
                                                    src="assets/cards/action_flip3.webp"
                                                    style="height:45px; border-radius:4px;"></div>
                                            <p style="font-size:13px; opacity:0.9; margin-top:6px; line-height:1.5;">
                                                Obbliga un avversario a pescare <strong>3 carte di fila</strong>. Se
                                                sballa durante questa sequenza,
                                                è fuori dal round ! ⚡ </p>
                                        </div>
                                    </div>
                                    <div class="action-rule"
                                        style="background:linear-gradient(90deg, rgba(244, 63, 94, 0.15), transparent); border-radius:12px; padding:15px; border:1px solid rgba(244, 63, 94, 0.3); display:flex; gap:20px; align-items:center;">
                                        <img src="https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Smilies/Heart%20on%20Fire.png"
                                            style="height:50px; filter: drop-shadow(0 0 8px rgba(244,63,94,0.5));"
                                            alt="SecondChance Icon">
                                        <div style="flex:1;">
                                            <div
                                                style="display:flex; justify-content:space-between; align-items:center;">
                                                <strong style="font-size:17px; color:#fda4af;">Second
                                                    Chance</strong><img src="assets/cards/action_second_chance.webp"
                                                    style="height:45px; border-radius:4px;"></div>
                                            <p style="font-size:13px; opacity:0.9; margin-top:6px; line-height:1.5;">Se
                                                sballi,
                                                questa carta viene consumata per <strong>annullare il Bust</strong>.
                                                Continuerai il tuo turno come se nulla fosse accaduto. ❤️‍🔥 </p>
                                        </div>
                                    </div>
                                </div>
                </div>
                <div
                    style="padding:20px 24px; border-top:1px solid rgba(255,255,255,0.1); text-align:center; flex-shrink:0;">
                    <button class="btn" style="width:100%; height: 50px; font-size: 16px; font-weight: 600;"
                        onclick="document.getElementById('rulesModal').classList.remove('active')">Ho capito !</button>
                </div>
            </div>
            <style>
                .rules-tabs .tab-btn {
                    flex: 1;
                    background: rgba(255, 255, 255, 0.1);
                    border: none;
                    padding: 10px;
                    color: rgba(255, 255, 255, 0.6);
                    cursor: pointer;
                    border-radius: 8px;
                    transition: all 0.2s;
                }

                .rules-tabs .tab-btn.active {
                    background: var(--primary);
                    color: white;
                    box-shadow: 0 4px 12px rgba(139, 92, 246, 0.3);
                }

                .tab-content {
                    display: none;
                    animation: fadeIn 0.3s;
                }

                .tab-content.active {
                    display: block;
                }

                @keyframes fadeIn {
                    from {
                        opacity: 0;
                        transform: translateY(5px);
                    }

                    to {
                        opacity: 1;
                        transform: translateY(0);
                    }
                }
            </style>
            <script>
                function switchTab(id) {
                    document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
                    document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
                    document.getElementById(id).classList.add('active');
                    event.target.classList.add('active');
                }
            </script>
        </div>

        <div class="modal" id="targetModal">
            <div class="modal-content glass">
                <h3 id="modalTitle">Scegli il bersaglio</h3>
                <div id="targetButtons"></div>
            </div>
        </div>

        <div id="endGameOverlay"
            style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.95); z-index:2000; align-items:center; justify-content:center; flex-direction:column; backdrop-filter:blur(20px); overflow-y:auto; padding:20px;">
            <div id="endGameStatus" style="text-align:center; margin-bottom:20px;"></div>
            <div id="endGameLeaderboard"
                style="width:100%; max-width:400px; background:rgba(255,255,255,0.08); border-radius:16px; padding:20px; border:1px solid rgba(255,255,255,0.1);">
            </div>
            <div id="endgameStatsContainer" class="endgame-stats"
                style="width:100%; max-width:500px; max-height:300px; overflow-y:auto;"></div>
            <button class="btn" id="btnRestartGame" onclick="restartGame()" style="margin-top:25px;">🔄 Nuova
                Partita</button>
        </div>

        <script>
            // ===== GAME ENGINE =====
            const qs = (s) => document.querySelector(s);
            document.getElementById('btnRules').addEventListener('click', () => qs('#rulesModal').classList.add('active'));

            function createDeck() {
                const d = [];
                for (let v = 0; v <= 12; v++) { const c = v === 0 ? 1 : v; for (let i = 0; i < c; i++) d.push({ type: 'number', value: v }); }
                ['freeze', 'flip3', 'second_chance'].forEach(v => { for (let i = 0; i < 3; i++) d.push({ type: 'action', value: v }) });
                ['+2', '+4', '+6', '+8', '+10', 'x2'].forEach(v => d.push({ type: 'modifier', value: v }));
                return shuffle(d);
            }
            function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[a[i], a[j]] = [a[j], a[i]]; } return a; }

            // ===== PREMIUM EFFECTS =====
            // Sound Effects using Howler.js (using Web Audio API synth for lightweight sounds)
            const SFX = {
                enabled: true,
                // Synth sounds created with Web Audio for lightweight experience
                play: function (type) {
                    if (!this.enabled) return;
                    try {
                        const ctx = new (window.AudioContext || window.webkitAudioContext)();
                        const osc = ctx.createOscillator();
                        const gain = ctx.createGain();
                        osc.connect(gain);
                        gain.connect(ctx.destination);

                        const sounds = {
                            card: { freq: 800, type: 'sine', dur: 0.08 },
                            hit: { freq: 600, type: 'triangle', dur: 0.1 },
                            bust: { freq: 200, type: 'sawtooth', dur: 0.3 },
                            win: { freq: 523, type: 'sine', dur: 0.2 },
                            action: { freq: 1000, type: 'square', dur: 0.15 },
                            flip7: { freq: 880, type: 'sine', dur: 0.4 },
                            click: { freq: 1200, type: 'sine', dur: 0.05 },
                            round: { freq: 440, type: 'triangle', dur: 0.25 }
                        };

                        const s = sounds[type] || sounds.click;
                        osc.frequency.setValueAtTime(s.freq, ctx.currentTime);
                        osc.type = s.type;
                        gain.gain.setValueAtTime(0.3, ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + s.dur);
                        osc.start();
                        osc.stop(ctx.currentTime + s.dur);
                    } catch (e) { }
                }
            };

            // Confetti Effects
            function fireConfetti(type = 'default') {
                if (typeof confetti === 'undefined') return;

                // Only fire for specific types if I am involved (checked at call site)
                if (type === 'flip7') {
                    // Rainbow explosion for Flip 7!
                    const duration = 3000;
                    const end = Date.now() + duration;
                    (function frame() {
                        confetti({
                            particleCount: 7, angle: 60, spread: 55, origin: { x: 0 },
                            colors: ['#A78BFA', '#C084FC', '#fbbf24', '#22c55e', '#3b82f6']
                        });
                        confetti({
                            particleCount: 7, angle: 120, spread: 55, origin: { x: 1 },
                            colors: ['#A78BFA', '#C084FC', '#fbbf24', '#22c55e', '#3b82f6']
                        });
                        if (Date.now() < end) requestAnimationFrame(frame);
                    })();
                } else if (type === 'win') {
                    // Victory celebration
                    confetti({
                        particleCount: 150, spread: 180, origin: { y: 0.6 },
                        colors: ['#FFD700', '#FFA500', '#FF6347', '#A78BFA']
                    });
                } else if (type === 'round') {
                    // Subtle round start
                    confetti({ particleCount: 30, spread: 60, origin: { y: 0.7 }, gravity: 1.5 });
                }
            }

            const ASSETS = {
                crown: 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Objects/Crown.png',
                heart: 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Smilies/Red%20Heart.png',
                snowflake: 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Travel%20and%20places/Snowflake.png',
                lightning: 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Travel%20and%20places/High%20Voltage.png',
                // FIX 6: Using Face Exhaling for stay reactions
                stop: 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Smilies/Face%20Exhaling.png',
                carta: 'https://em-content.zobj.net/source/microsoft-teams/400/palm-up-hand_medium-light-skin-tone_1faf4-1f3fc_1f3fc.png',
                frozen: 'https://em-content.zobj.net/source/microsoft-teams/400/cold-face_1f976.png',
                sc: 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Smilies/Heart%20on%20Fire.png',
                fire: 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Travel%20and%20places/Fire.png',
                star: 'https://em-content.zobj.net/source/microsoft-teams/400/star-struck_1f929.png',
                bust: 'https://em-content.zobj.net/source/microsoft-teams/400/loudly-crying-face_1f62d.png',
                bust_alt: 'https://em-content.zobj.net/source/microsoft-teams/400/face-with-symbols-on-mouth_1f92c.png',
                fear: 'https://em-content.zobj.net/source/microsoft-teams/400/face-screaming-in-fear_1f631.png',
                hot: 'https://em-content.zobj.net/source/microsoft-teams/400/hot-face_1f975.png'
            };

            const FLUENT_BASE = 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis';

            // Varied collections for events
            const ASSETS_COLLECTIONS = {
                bust: [
                    ASSETS.bust,
                    ASSETS.bust_alt,
                    `${FLUENT_BASE}/Smilies/Woozy%20Face.png`,
                    `${FLUENT_BASE}/Smilies/Exploding%20Head.png`,
                    `${FLUENT_BASE}/Smilies/Face%20Vomiting.png`
                ],
                flip7: [
                    ASSETS.star,
                    ASSETS.fire,
                    `${FLUENT_BASE}/Activities/Party%20Popper.png`,
                    `${FLUENT_BASE}/Activities/Trophy.png`,
                    `${FLUENT_BASE}/Activities/1st%20Place%20Medal.png`
                ],
                win: [
                    `${FLUENT_BASE}/Activities/Confetti%20Ball.png`,
                    `${FLUENT_BASE}/Activities/Party%20Popper.png`,
                    `${FLUENT_BASE}/Smilies/Partying%20Face.png`
                ]
            };

            // APNG PATH STRATEGY - PLEASE READ DO NOT MODIFY
            // ------------------------------------------------
            // Emoji paths MUST be fully qualified or strictly encoded to avoid 404 errors.
            // 1. Files from 'Tarikul-Islam-Anik/Animated-Fluent-Emojis' often have spaces in filenames.
            // 2. We MUST encode these spaces as '%20' manually in the strings below.
            // 3. Do NOT use local paths (e.g. 'Emojis/...') as they may fail if assets aren't downloaded.
            // 4. Always use `${FLUENT_BASE}` or the full raw.githubusercontent.com URL.
            const REACTIONS = [
                // Hand Gestures
                { id: 'like', src: `${FLUENT_BASE}/Hand%20gestures/Thumbs%20Up.png` },
                { id: 'dislike', src: `${FLUENT_BASE}/Hand%20gestures/Thumbs%20Down.png` },
                { id: 'ok', src: `${FLUENT_BASE}/Hand%20gestures/OK%20Hand.png` },
                { id: 'peace', src: `${FLUENT_BASE}/Hand%20gestures/Victory%20Hand.png` },
                { id: 'fingers_crossed', src: `${FLUENT_BASE}/Hand%20gestures/Crossed%20Fingers.png` },
                { id: 'love_you', src: `${FLUENT_BASE}/Hand%20gestures/Love-You%20Gesture.png` },
                { id: 'clap', src: `${FLUENT_BASE}/Hand%20gestures/Clapping%20Hands.png` },
                { id: 'wave', src: `${FLUENT_BASE}/Hand%20gestures/Waving%20Hand.png` },
                { id: 'pray', src: `${FLUENT_BASE}/Hand%20gestures/Folded%20Hands.png` },
                { id: 'stop', src: `${FLUENT_BASE}/Hand%20gestures/Raised%20Hand.png` },
                { id: 'muscle', src: `${FLUENT_BASE}/People%20with%20activities/Person%20Lifting%20Weights%20Light%20Skin%20Tone.png` },

                // Smilies & Emotions
                { id: 'laugh', src: `${FLUENT_BASE}/Smilies/Face%20with%20Tears%20of%20Joy.png` },
                { id: 'cry', src: `${FLUENT_BASE}/Smilies/Loudly%20Crying%20Face.png` },
                { id: 'angry', src: `${FLUENT_BASE}/Smilies/Enraged%20Face.png` },
                { id: 'shock', src: `${FLUENT_BASE}/Smilies/Face%20Screaming%20in%20Fear.png` },
                { id: 'heart', src: `${FLUENT_BASE}/Smilies/Smiling%20Face%20with%20Heart-Eyes.png` },
                { id: 'cool', src: `${FLUENT_BASE}/Smilies/Smiling%20Face%20with%20Sunglasses.png` },
                { id: 'thinking', src: `${FLUENT_BASE}/Smilies/Thinking%20Face.png` },
                { id: 'devil', src: `${FLUENT_BASE}/Smilies/Smiling%20Face%20with%20Horns.png` },
                { id: 'angel', src: `${FLUENT_BASE}/Smilies/Smiling%20Face%20with%20Halo.png` },
                { id: 'money', src: `${FLUENT_BASE}/Smilies/Money-Mouth%20Face.png` },
                { id: 'nerd', src: `${FLUENT_BASE}/Smilies/Nerd%20Face.png` },
                { id: 'sick', src: `${FLUENT_BASE}/Smilies/Nauseated%20Face.png` },
                { id: 'clown', src: `${FLUENT_BASE}/Smilies/Clown%20Face.png` },
                { id: 'ghost', src: `${FLUENT_BASE}/Smilies/Ghost.png` },
                { id: 'poop', src: `${FLUENT_BASE}/Smilies/Pile%20of%20Poo.png` },
                { id: 'skull', src: `${FLUENT_BASE}/Smilies/Skull.png` },
                { id: 'shush', src: `${FLUENT_BASE}/Smilies/Shushing%20Face.png` },
                { id: 'zany', src: `${FLUENT_BASE}/Smilies/Zany%20Face.png` },
                { id: 'pleading', src: `${FLUENT_BASE}/Smilies/Pleading%20Face.png` },
                { id: 'pout', src: `${FLUENT_BASE}/People%20with%20activities/Man%20in%20Motorized%20Wheelchair%20Light%20Skin%20Tone.png` },
                { id: 'hot', src: `${FLUENT_BASE}/Smilies/Hot%20Face.png` },
                { id: 'cold', src: `${FLUENT_BASE}/Smilies/Cold%20Face.png` },
                { id: 'explode', src: `${FLUENT_BASE}/Smilies/Exploding%20Head.png` },
                { id: 'cowboy', src: `${FLUENT_BASE}/Smilies/Cowboy%20Hat%20Face.png` },

                // Activities & Objects
                { id: 'fire', src: `${FLUENT_BASE}/Travel%20and%20places/Fire.png` },
                { id: 'party', src: `${FLUENT_BASE}/Activities/Party%20Popper.png` },
                { id: 'star', src: `${FLUENT_BASE}/Travel%20and%20places/Star.png` },
                { id: 'trophy', src: `${FLUENT_BASE}/Activities/Trophy.png` },
                { id: 'medal', src: `${FLUENT_BASE}/Activities/1st%20Place%20Medal.png` },
                { id: 'bomb', src: `${FLUENT_BASE}/Smilies/Bomb.png` },
                { id: 'gift', src: `${FLUENT_BASE}/Activities/Wrapped%20Gift.png` },
                { id: 'gem', src: `${FLUENT_BASE}/Objects/Gem%20Stone.png` }, // Using generic path
                // Animals (some might need check but usually exist)
                { id: 'cat', src: `${FLUENT_BASE}/Animals/Cat%20Face.png` },
                { id: 'dog', src: `${FLUENT_BASE}/Animals/Dog%20Face.png` },
                { id: 'monkey', src: `${FLUENT_BASE}/Animals/Monkey%20Face.png` },
                { id: 'bust', src: `${FLUENT_BASE}/Smilies/Skull.png` } // Kept for bust usage
            ];

            function getRandAsset(key) {
                const arr = ASSETS_COLLECTIONS[key];
                return arr ? arr[Math.floor(Math.random() * arr.length)] : (ASSETS[key] || '');
            }

            let lastReactTime = 0; // Cooldown tracker

            let peer = null, conns = [], isHost = false, myId = '', myName = '', roomId = '',
                state = {
                    phase: 'lobby',
                    round: 1,
                    deck: [],
                    players: [],
                    discards: [],
                    dealer: 0,
                    turn: 0,
                    last: null,
                    pending: null,
                    history: [],
                    // New Logic States
                    dealingPhase: false,
                    dealIndex: 0,
                    turnOrder: [],
                    flip3Queue: []
                },
                // Local state to track rendered cards and avoid re-animations
                localPlayerCardCounts = {},
                localAnimatingCards = {};

            let localLastToastId = 0;

            // ========== STATS DASHBOARD (READ-ONLY TRACKING) ==========
            let gameStats = {
                players: [], // Will be populated with PlayerStats objects
                rounds: 0,
                totalCardsDealt: 0,
                flip7Total: 0,
                actionTypes: { freeze: 0, flip3: 0, secondChance: 0 }
            };

            let statsCharts = {}; // Store chart instances

            function initGameStats() {
                gameStats = {
                    players: state.players.map(p => ({
                        id: p.id,
                        name: p.name,
                        bust: 0,
                        stay: 0,
                        flip7: 0,
                        secondChance: 0,
                        totalCards: 0,
                        totalScore: 0,
                        rounds: []
                    })),
                    rounds: 0,
                    totalCardsDealt: 0,
                    flip7Total: 0,
                    actionTypes: { freeze: 0, flip3: 0, secondChance: 0 }
                };
            }

            function getPlayerStats(playerId) {
                return gameStats.players.find(p => p.id === playerId);
            }

            // TRACKING FUNCTIONS (called passively from existing logic)
            function trackBust(playerId) {
                const ps = getPlayerStats(playerId);
                if (ps) ps.bust++;
            }

            function trackStay(playerId) {
                const ps = getPlayerStats(playerId);
                if (ps) ps.stay++;
            }

            function trackFlip7(playerId) {
                const ps = getPlayerStats(playerId);
                if (ps) ps.flip7++;
                gameStats.flip7Total++;
            }

            function trackSecondChance(playerId) {
                const ps = getPlayerStats(playerId);
                if (ps) ps.secondChance++;
                gameStats.actionTypes.secondChance++;
            }

            function trackCardDealt(playerId) {
                const ps = getPlayerStats(playerId);
                if (ps) ps.totalCards++;
                gameStats.totalCardsDealt++;
            }

            function trackAction(actionType) {
                if (gameStats.actionTypes[actionType] !== undefined) {
                    gameStats.actionTypes[actionType]++;
                }
            }

            function trackRoundEnd() {
                gameStats.rounds++;
                state.players.forEach(p => {
                    const ps = getPlayerStats(p.id);
                    if (ps) {
                        ps.rounds.push(p.st === 'bust' ? 'bust' : p.pts);
                        ps.totalScore = p.tot;
                    }
                });
            }

            // STATS SHEET CONTROLS
            function openStatsSheet() {
                document.getElementById('statsSheet').classList.add('open');
                renderStatsCharts();
            }

            function closeStatsSheet() {
                document.getElementById('statsSheet').classList.remove('open');
            }

            function toggleStatsSheet() {
                const sheet = document.getElementById('statsSheet');
                if (sheet.classList.contains('open')) {
                    closeStatsSheet();
                } else {
                    openStatsSheet();
                    // Close sidebar if open (UX improvement)
                    if (document.getElementById('leaderboardSidebar').classList.contains('active')) {
                        toggleSidebar('leaderboardSidebar');
                    }
                }
            }

            // CHART RENDERING
            function renderStatsCharts() {
                if (!window.Chart) return; // Chart.js not loaded

                const playerColors = ['#FF6B35', '#8B5CF6', '#10B981', '#3B82F6', '#F59E0B', '#EC4899'];
                const playerNames = gameStats.players.map(p => p.name);

                // 1. LINE CHART - Cumulative Score
                const lineCtx = document.getElementById('chartLine');
                if (lineCtx) {
                    if (statsCharts.line) statsCharts.line.destroy();
                    const roundLabels = Array.from({ length: gameStats.rounds || 1 }, (_, i) => `R${i + 1}`);
                    const datasets = gameStats.players.map((p, i) => {
                        let cumulative = 0;
                        const data = p.rounds.map(r => {
                            if (r !== 'bust') cumulative += r;
                            return cumulative;
                        });
                        return {
                            label: p.name,
                            data: data.length ? data : [0],
                            borderColor: playerColors[i % playerColors.length],
                            backgroundColor: playerColors[i % playerColors.length] + '33',
                            tension: 0.3,
                            fill: false
                        };
                    });
                    statsCharts.line = new Chart(lineCtx, {
                        type: 'line',
                        data: { labels: roundLabels.length ? roundLabels : ['R1'], datasets },
                        options: {
                            responsive: true,
                            plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } },
                            scales: {
                                x: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                                y: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                            }
                        }
                    });
                }

                // 2. BAR CHART - Actions per Player
                const barCtx = document.getElementById('chartBar');
                if (barCtx) {
                    if (statsCharts.bar) statsCharts.bar.destroy();
                    statsCharts.bar = new Chart(barCtx, {
                        type: 'bar',
                        data: {
                            labels: playerNames,
                            datasets: [
                                { label: 'Bust', data: gameStats.players.map(p => p.bust), backgroundColor: '#EF4444' },
                                { label: 'Stay', data: gameStats.players.map(p => p.stay), backgroundColor: '#10B981' },
                                { label: 'Flip7', data: gameStats.players.map(p => p.flip7), backgroundColor: '#8B5CF6' }
                            ]
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } },
                            scales: {
                                x: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                                y: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                            }
                        }
                    });
                }

                // 3. DONUT CHART - Action Distribution
                const donutCtx = document.getElementById('chartDonut');
                if (donutCtx) {
                    if (statsCharts.donut) statsCharts.donut.destroy();
                    statsCharts.donut = new Chart(donutCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Freeze', 'Flip3', 'Second Chance', 'Flip7 Bonus'],
                            datasets: [{
                                data: [
                                    gameStats.actionTypes.freeze,
                                    gameStats.actionTypes.flip3,
                                    gameStats.actionTypes.secondChance,
                                    gameStats.flip7Total
                                ],
                                backgroundColor: ['#38BDF8', '#FBBF24', '#F87171', '#A78BFA']
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } }
                        }
                    });
                }

                // 4. HEATMAP (simplified as stacked bar) - Cards vs Outcome
                const heatCtx = document.getElementById('chartHeatmap');
                if (heatCtx) {
                    if (statsCharts.heat) statsCharts.heat.destroy();
                    statsCharts.heat = new Chart(heatCtx, {
                        type: 'bar',
                        data: {
                            labels: playerNames,
                            datasets: [
                                { label: 'Carte Pescate', data: gameStats.players.map(p => p.totalCards), backgroundColor: '#3B82F6' },
                                { label: 'Punti Totali', data: gameStats.players.map(p => p.totalScore), backgroundColor: '#10B981' }
                            ]
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } },
                            scales: {
                                x: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } },
                                y: { ticks: { color: '#aaa' }, grid: { color: 'rgba(255,255,255,0.1)' } }
                            }
                        }
                    });
                }

                // 5. RADAR CHART - Performance vs Average
                const radarCtx = document.getElementById('chartRadar');
                if (radarCtx) {
                    if (statsCharts.radar) statsCharts.radar.destroy();
                    const avgBust = gameStats.players.reduce((a, p) => a + p.bust, 0) / (gameStats.players.length || 1);
                    const avgStay = gameStats.players.reduce((a, p) => a + p.stay, 0) / (gameStats.players.length || 1);
                    const avgCards = gameStats.players.reduce((a, p) => a + p.totalCards, 0) / (gameStats.players.length || 1);
                    const avgScore = gameStats.players.reduce((a, p) => a + p.totalScore, 0) / (gameStats.players.length || 1);

                    const datasets = gameStats.players.map((p, i) => ({
                        label: p.name,
                        data: [p.bust, p.stay, p.totalCards / 10, p.totalScore / 20, p.flip7],
                        borderColor: playerColors[i % playerColors.length],
                        backgroundColor: playerColors[i % playerColors.length] + '44'
                    }));

                    statsCharts.radar = new Chart(radarCtx, {
                        type: 'radar',
                        data: {
                            labels: ['Bust', 'Stay', 'Carte/10', 'Punti/20', 'Flip7'],
                            datasets
                        },
                        options: {
                            responsive: true,
                            plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } },
                            scales: {
                                r: {
                                    angleLines: { color: 'rgba(255,255,255,0.2)' },
                                    grid: { color: 'rgba(255,255,255,0.1)' },
                                    pointLabels: { color: '#aaa' },
                                    ticks: { display: false }
                                }
                            }
                        }
                    });
                }
            }

            // END-GAME STATS RENDER
            function renderEndgameStats(container) {
                if (!window.Chart || !container) return;

                container.innerHTML = `
                <h3>📊 Statistiche Finali</h3>
                <div class="stats-grid">
                    <div class="chart-card full-width"><h4>📈 Punteggio Cumulativo</h4><canvas id="endChartLine"></canvas></div>
                    <div class="chart-card"><h4>📊 Azioni per Giocatore</h4><canvas id="endChartBar"></canvas></div>
                    <div class="chart-card"><h4>🎯 Distribuzione Azioni</h4><canvas id="endChartDonut"></canvas></div>
                    <div class="chart-card"><h4>⚖️ Carte vs Punti</h4><canvas id="endChartHeatmap"></canvas></div>
                    <div class="chart-card"><h4>🕸️ Performance Radar</h4><canvas id="endChartRadar"></canvas></div>
                </div>
            `;

                // Re-render simplified charts
                setTimeout(() => {
                    const playerColors = ['#FF6B35', '#8B5CF6', '#10B981', '#3B82F6', '#F59E0B', '#EC4899'];
                    const playerNames = gameStats.players.map(p => p.name);
                    const roundLabels = Array.from({ length: gameStats.rounds || 1 }, (_, i) => `R${i + 1}`);

                    // Line
                    const lineData = gameStats.players.map((p, i) => {
                        let cum = 0;
                        return {
                            label: p.name,
                            data: p.rounds.map(r => { if (r !== 'bust') cum += r; return cum; }),
                            borderColor: playerColors[i % playerColors.length],
                            tension: 0.3, fill: false
                        };
                    });
                    new Chart(document.getElementById('endChartLine'), {
                        type: 'line',
                        data: { labels: roundLabels.length ? roundLabels : ['R1'], datasets: lineData },
                        options: {
                            responsive: true, plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } },
                            scales: { x: { ticks: { color: '#aaa' } }, y: { ticks: { color: '#aaa' } } }
                        }
                    });

                    // Bar
                    new Chart(document.getElementById('endChartBar'), {
                        type: 'bar',
                        data: {
                            labels: playerNames,
                            datasets: [
                                { label: 'Bust', data: gameStats.players.map(p => p.bust), backgroundColor: '#EF4444' },
                                { label: 'Stay', data: gameStats.players.map(p => p.stay), backgroundColor: '#10B981' }
                            ]
                        },
                        options: { responsive: true, plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } } }
                    });

                    // Donut
                    new Chart(document.getElementById('endChartDonut'), {
                        type: 'doughnut',
                        data: {
                            labels: ['Freeze', 'Flip3', 'Second Chance', 'Flip7'],
                            datasets: [{ data: [gameStats.actionTypes.freeze, gameStats.actionTypes.flip3, gameStats.actionTypes.secondChance, gameStats.flip7Total], backgroundColor: ['#38BDF8', '#FBBF24', '#F87171', '#A78BFA'] }]
                        },
                        options: { responsive: true, plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } } }
                    });

                    // Heatmap (Stacked Bar)
                    new Chart(document.getElementById('endChartHeatmap'), {
                        type: 'bar',
                        data: {
                            labels: playerNames,
                            datasets: [
                                { label: 'Carte Pescate', data: gameStats.players.map(p => p.totalCards), backgroundColor: '#3B82F6' },
                                { label: 'Punti Totali', data: gameStats.players.map(p => p.totalScore), backgroundColor: '#10B981' }
                            ]
                        },
                        options: {
                            responsive: true, plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } },
                            scales: { x: { ticks: { color: '#aaa' } }, y: { ticks: { color: '#aaa' } } }
                        }
                    });

                    // Radar
                    const radarDatasets = gameStats.players.map((p, i) => ({
                        label: p.name,
                        data: [p.bust, p.stay, p.totalCards / 10, p.totalScore / 20, p.flip7],
                        borderColor: playerColors[i % playerColors.length],
                        backgroundColor: playerColors[i % playerColors.length] + '44'
                    }));
                    new Chart(document.getElementById('endChartRadar'), {
                        type: 'radar',
                        data: {
                            labels: ['Bust', 'Stay', 'Carte/10', 'Punti/20', 'Flip7'],
                            datasets: radarDatasets
                        },
                        options: {
                            responsive: true, plugins: { legend: { labels: { usePointStyle: true, color: '#fff' } } },
                            scales: {
                                r: {
                                    angleLines: { color: 'rgba(255,255,255,0.2)' },
                                    grid: { color: 'rgba(255,255,255,0.1)' },
                                    pointLabels: { color: '#aaa' },
                                    ticks: { display: false }
                                }
                            }
                        }
                    });
                }, 100);
            }
            // ========== END STATS DASHBOARD ==========


            function toggleSidebar(id) {
                const el = document.getElementById(id);
                // Close others
                document.querySelectorAll('.sidebar').forEach(s => { if (s.id !== id) s.classList.remove('active'); });
                el.classList.toggle('active');
            }

            // Close sidebars on click outside
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.sidebar') && !e.target.closest('.sidebar-tab')) {
                    document.querySelectorAll('.sidebar.active').forEach(s => s.classList.remove('active'));
                }
            });

            function addToHistory(text, type = 'normal') {
                if (!isHost) return; // Only host manages history state
                state.history.unshift({ t: text, type: type, time: Date.now() });
                if (state.history.length > 15) state.history.pop(); // Keep last 15
                sync(); updateGame();
            }

            function initPeer(id) {
                return new Promise((res, rej) => {
                    peer = new Peer(id, { debug: 0 });
                    peer.on('open', res); peer.on('error', rej);
                    peer.on('connection', c => {
                        c.on('open', () => { conns.push(c); c.on('data', d => handleMsg(c, d)); c.on('close', () => conns = conns.filter(x => x != c)); });
                    });
                });
            }

            function handleMsg(c, d) {
                if (d.t === 'join' && isHost) {
                    state.players.push({ id: c.peer, name: d.name, cards: [], mods: [], nums: [], pts: 0, tot: 0, st: 'active', sc: false });
                    bc({ t: 'state', s: serState() }); updateLobby();
                } else if (d.t === 'state') {
                    desState(d.s);
                    // Always update lobby if in lobby phase (fixes joiner visibility)
                    if (state.phase === 'lobby') updateLobby();
                    else updateGame();
                }
                else if (d.t === 'act' && isHost) handleAct(c.peer, d.a, d.tgt);
                else if (d.t === 'reaction' && isHost) {
                    // Host receives reaction request from client
                    // Find who sent it? c.peer is the ID.
                    const pId = c.peer;
                    bc({ t: 'reaction', who: pId, id: d.id });
                    showReaction(pId, d.id);
                }
                else if (d.t === 'reaction' && !isHost) showReaction(d.who, d.id);
                else if (d.t === 'splash') showCardSplash(d.a, d.who);
                else if (d.t === 'start') startGame();
                else if (d.t === 'restart') {
                    // Client handles restart from host
                    qs('#endGameOverlay').style.display = 'none';
                    qs('#flip7Overlay').style.display = 'none';
                    qs('#recapOverlay').classList.remove('active');
                    showToast('🎮 Nuova partita iniziata!');
                }
                else if (d.t === 'broadcast_toast') {
                    // All clients show the broadcast toast
                    showBroadcastToast(d.type, d.from, d.target);
                }
                // FIX 1: Handle SC burn when alone broadcast
                else if (d.t === 'sc_burn_alone') {
                    showSCBurnAloneSplash(d.who);
                }
                // FIX 8: Handle smoke broadcast for bust
                else if (d.t === 'smoke') {
                    spawnSmokeOnPlayer(d.who);
                }
            }

            function bc(d) { conns.forEach(c => c.send(d)); }
            function sendHost(d) { if (conns[0]) conns[0].send(d); }
            function serState() { return { ...state, players: state.players.map(p => ({ ...p, nums: Array.from(p.nums || []) })), gameStats: gameStats }; }
            function desState(s) { state = { ...s, players: s.players.map(p => ({ ...p, nums: new Set(p.nums || []) })) }; if (s.gameStats) gameStats = s.gameStats; }

            // === REACTION SYSTEM ===
            function showReaction(pId, rId) {
                const pIdx = state.players.findIndex(p => p.id === pId);
                if (pIdx < 0) return;
                const zone = qs(`#pzone-${pIdx}`);
                if (!zone) return;

                const rData = REACTIONS.find(r => r.id === rId);
                if (!rData) return;

                // Target the reaction-overlay inside modifiers-row
                let overlay = zone.querySelector('.reaction-overlay');
                if (!overlay) {
                    // Fallback to floating if overlay not found
                    overlay = zone;
                }

                // Special Handling for STOP (Stay)
                if (rId === 'stop') {
                    const stopsEl = document.createElement('div');
                    stopsEl.innerHTML = `<img src="${rData.src}" style="height:40px; filter:drop-shadow(0 0 5px green); animation: popIn 0.3s ease-out;">`;
                    // Append directly to overlay (flex container) so it sits next to other icons
                    // ensure overlay is the flex container
                    if (overlay.classList.contains('reaction-overlay')) {
                        overlay.appendChild(stopsEl);
                        // Remove after sometime? Or keep it? 
                        // Usually 'Stay' is a status. But this is a reaction.
                        // "Quando un player si ferma... visualizziamo l'APNG"
                        // If it's the 'Stop' SIGN, it might be transient.
                        // But if they stay, they stay. 
                        // Let's make it transient as it's a "Reaction". 
                        // Permanent status is handled by badges/border/opacity.
                        setTimeout(() => stopsEl.remove(), 3000);
                    } else {
                        // Fallback if overlay not found (floating)
                        stopsEl.style.cssText = `position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); z-index:100; pointer-events:none; animation: fadePop 3s ease-out;`;
                        overlay.appendChild(stopsEl);
                        setTimeout(() => stopsEl.remove(), 3000);
                    }
                    SFX.play('click');
                    return;
                }

                // Standard reactions: use floating side messages
                const player = state.players.find(p => p.id === pId);
                const playerName = player ? player.name : 'Giocatore';
                showFloatingReaction(playerName, rData);
                SFX.play('card'); // Pop sound
            }

            // Floating reaction message from the side
            function showFloatingReaction(playerName, rData) {
                const el = document.createElement('div');
                el.className = 'floating-reaction';
                el.innerHTML = `<strong>${playerName}:</strong> <img src="${rData.src}" style="height:32px;">`;

                // Stack multiple reactions
                const existingCount = document.querySelectorAll('.floating-reaction').length;
                el.style.top = `${120 + existingCount * 60}px`;

                document.body.appendChild(el);
                setTimeout(() => {
                    el.style.opacity = '0';
                    el.style.transform = 'translateX(100px)';
                    el.style.transition = 'all 0.3s ease-out';
                    setTimeout(() => el.remove(), 300);
                }, 2500);
            }

            function initReactions() {
                const p = qs('#reactionPicker');
                if (!p) return;
                p.innerHTML = REACTIONS.map(r => `
                <div class="reaction-opt" onclick="sendReaction('${r.id}')" style="cursor:pointer; padding:5px; border-radius:8px; display:flex; justify-content:center; align-items:center; transition:transform 0.2s;">
                    <img src="${r.src}" style="width:32px; height:32px; pointer-events:none;">
                </div>
            `).join('');

                p.querySelectorAll('.reaction-opt').forEach(el => {
                    el.onmouseenter = () => el.style.transform = 'scale(1.2)';
                    el.onmouseleave = () => el.style.transform = 'scale(1)';
                });

                const btn = qs('#btnReact');
                if (btn) btn.onclick = (e) => {
                    e.stopPropagation();
                    // Only open if enabled
                    if (btn.disabled) return;

                    const isVis = p.style.display === 'grid';
                    p.style.display = isVis ? 'none' : 'grid';
                    setTimeout(() => p.style.opacity = isVis ? 0 : 1, 10);
                };

                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#btnReact') && !e.target.closest('#reactionPicker')) {
                        p.style.display = 'none';
                        p.style.opacity = 0;
                    }
                });
            }

            function sendReaction(id) {
                if (Date.now() - lastReactTime < 3000) return;
                lastReactTime = Date.now();

                qs('#reactionPicker').style.display = 'none';
                const btn = qs('#btnReact');
                btn.style.transform = 'scale(0.8) grayscale(1)';
                setTimeout(() => btn.style.transform = '', 3000);

                if (isHost) {
                    bc({ t: 'reaction', who: myId, id });
                    showReaction(myId, id);
                } else {
                    sendHost({ t: 'reaction', id });
                }
            }

            // Defer init
            setTimeout(initReactions, 500);

            // Stats Button Click Handler
            setTimeout(() => {
                const statsBtn = qs('#btnStats');
                if (statsBtn) statsBtn.onclick = toggleStatsSheet;
            }, 500);

            function showCardSplash(type, who) {
                const overlay = document.createElement('div');
                overlay.className = 'action-splash';
                document.body.appendChild(overlay);

                // Use getRandAsset to pick varied 3D emojis
                // If type is a URL (from showCardSplash call), use it directly.
                // If type is a key (bust, flip7), use getRandAsset.
                // MOD: Use Flip7 Logo for star/flip7
                const src = (type === 'star' || type === 'flip7') ? 'assets/Flip7 Logo.webp' : (type.startsWith('http') ? type : (getRandAsset(type) || ASSETS[type] || ASSETS.warning));

                let html = `<div class="card action" style="transform:scale(1.8); box-shadow:0 0 30px rgba(0,0,0,0.5); background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);">
                <img src="${src}" style="width:80%; height:auto; filter:drop-shadow(0 0 10px rgba(255,255,255,0.5));">
            </div>`;

                if (who && who !== myName) {
                    const prettyNames = { 'freeze': 'Freeze', 'flip3': 'Flip 3', 'second_chance': 'Second Chance', 'bust': 'BUST!', 'hot': '2nd Chance!', 'star': 'FLIP 7!' };
                    // If type is URL, default name
                    const nameStr = prettyNames[type] || (type.startsWith('http') ? 'Evento!' : type.toUpperCase());

                    html += `<div style="color:white; font-size:28px; margin-top:50px; text-shadow:0 2px 10px black; font-weight:800; text-align:center; animation:fadeIn 0.5s 0.3s both; background:rgba(0,0,0,0.4); padding:10px 20px; border-radius:15px; border:1px solid rgba(255,255,255,0.2);">
                    ${who} 
                    <div style="display:flex; align-items:center; justify-content:center; gap:8px; font-size:18px; font-weight:400; opacity:0.9; margin-top:5px;">
                        ${nameStr} 
                        <img src="${src}" style="height:24px;">
                    </div>
                </div>`;
                }
                overlay.innerHTML = `<div style="display:flex; flex-direction:column; align-items:center; justify-content:center;">${html}</div>`;

                setTimeout(() => {
                    overlay.style.opacity = '0';
                    setTimeout(() => overlay.remove(), 500);
                }, 2000);
            }

            function spawnSmokeOnPlayer(pId) {
                const pIdx = state.players.findIndex(p => p.id === pId);
                if (pIdx < 0) return;
                const zone = qs(`#pzone-${pIdx}`);
                if (!zone) return;
                const rect = zone.getBoundingClientRect();
                const center = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };

                for (let i = 0; i < 10; i++) {
                    setTimeout(() => spawnSmoke(center.x, center.y), i * 80);
                }
            }

            function spawnSmoke(x, y) {
                const el = document.createElement('div');
                el.className = 'smoke-particle';
                const size = 30 + Math.random() * 50;
                el.style.width = `${size}px`; el.style.height = `${size}px`;
                const offX = (Math.random() - 0.5) * 80;
                const offY = (Math.random() - 0.5) * 50;
                el.style.left = `${x + offX}px`; el.style.top = `${y + offY}px`;
                document.body.appendChild(el);
                setTimeout(() => el.remove(), 2500);
            }

            qs('#btnCreateRoom').onclick = async () => {
                const n = qs('#nickname').value.trim();
                if (!n) { showToast('⚠️ Inserisci un nickname!'); return; }
                myName = n; roomId = 'flip7-' + Math.random().toString(36).substr(2, 6).toUpperCase();
                try {
                    await initPeer(roomId); isHost = true; myId = roomId;
                    state.players.push({ id: myId, name: myName, cards: [], mods: [], nums: new Set(), pts: 0, tot: 0, st: 'active', sc: false });
                    window.isCreatingRoom = true; // Flag to customize toast
                    window.location.hash = roomId; showRoom();
                } catch (e) { showToast('❌ Errore creazione stanza'); }
            };

            qs('#btnJoinRoom').onclick = async () => {
                const n = qs('#nickname').value.trim(), h = window.location.hash.slice(1);
                if (!n || !h?.startsWith('flip7-')) { showToast('⚠️ Inserisci nickname e codice stanza!'); return; }
                myName = n; roomId = h;
                try {
                    await initPeer(); myId = peer.id;
                    const c = peer.connect(roomId, { reliable: true });
                    c.on('open', () => { conns.push(c); c.send({ t: 'join', name: myName }); c.on('data', d => handleMsg(c, d)); });
                    qs('#hostControls').style.display = 'none';
                    // Show waiting screen part of room info immediately
                    qs('#roomInfo').style.display = 'block';
                    qs('.room-link').style.display = 'none'; // Hide invite link for joiner initially
                    qs('#playersList').innerHTML = '<div style="padding:10px">Connessione...</div>';
                } catch (e) { showToast('❌ Errore connessione'); }
            };

            function showRoom() {
                qs('#hostControls').style.display = 'none';
                qs('#roomInfo').style.display = 'block';
                const url = location.href;
                qs('#roomLink').innerText = url;
                qs('#roomLink').href = url;
                qs('#qrcode').innerHTML = '';
                new QRCode(qs('#qrcode'), { text: url, width: 128, height: 128 });
                updateLobby();
            }

            window.copyRoomLink = () => { navigator.clipboard.writeText(location.href); alert('Link copiato!'); };

            function updateLobby() {
                // Ensure container is visible for joiners receiving updates
                qs('#roomInfo').style.display = 'block';
                if (!isHost) qs('.room-link').style.display = 'block'; // Now joiner can also invite others if they want

                qs('#playersList').innerHTML = state.players.map((p, i) => `<div class="player-item ${i === 0 ? 'host' : ''}">${p.name}${p.id === myId ? ' (Tu)' : ''} ${i === 0 ? '👑' : ''}</div>`).join('');
                if (isHost && state.players.length >= 2) qs('#btnStartGame').style.display = 'block';
            }

            qs('#btnStartGame').onclick = function () {
                if (this.disabled) return;
                this.disabled = true; // Prevent double click
                if (isHost) { bc({ t: 'start' }); startGame(); }
            };

            function startGame() {
                state.phase = 'game';
                state.deck = createDeck(); // First game always new deck
                state.discards = [];
                state.round = 1;
                state.dealer = 0;
                initGameStats(); // Initialize stats tracking
                resetRound(); qs('#lobby').style.display = 'none'; qs('#gameContainer').classList.add('active');

                // Shuffle Animation (Visual only)
                const deckEl = qs('.deck');
                if (deckEl) {
                    deckEl.classList.add('shuffling');
                    showToast("Mescolo le carte... 🔀");
                    setTimeout(() => {
                        deckEl.classList.remove('shuffling');
                        dealInit();
                    }, 1200);
                } else {
                    dealInit();
                }
            }

            function restartGame() {
                // Only host can restart
                if (!isHost) return;

                // Reset state but keep players connected
                state.phase = 'game';
                state.deck = createDeck();
                state.discards = [];
                state.round = 1;
                state.dealer = 0;
                state.players.forEach(p => { p.tot = 0; }); // Reset total scores

                // For restart, we DO reset the deck completely
                state.deck = createDeck();
                state.discards = [];

                resetRound();

                // Hide all overlays
                qs('#endGameOverlay').style.display = 'none';
                qs('#flip7Overlay').style.display = 'none';
                qs('#recapOverlay').classList.remove('active');

                // Broadcast restart to all players
                bc({ t: 'restart' });

                // Start new game
                dealInit();
                showToast('🎮 Nuova partita iniziata!');
            }

            function resetRound() {
                state.players.forEach(p => {
                    p.cards = []; p.mods = []; p.nums = new Set(); p.pts = 0;
                    p.st = 'active'; p.sc = false; p.frozen = false; p.flip3Active = false;
                });
                state.last = null; state.pending = null;
                state.dealingPhase = false; state.flip3Queue = [];
                state.dealingPaused = false; // FIX: Prevent race condition in deal loop
                state.flip3State = null; // FIX: Queue/Pause state for Flip3
                localPlayerCardCounts = {}; // Reset local animation tracking
                qs('body').classList.remove('animation-blocked'); // Ensure UI is unlocked
            }

            function dealInit() {
                // Build Turn Order: Dealer+1 ... End, then 0 ... Dealer
                state.turnOrder = [];
                for (let i = 0; i < state.players.length; i++) {
                    state.turnOrder.push((state.dealer + 1 + i) % state.players.length);
                }
                state.dealingPhase = true;
                state.dealIndex = 0;
                state.dealingPaused = false;

                dealLoop();
            }

            // ... dealLoop ...

            // ...

            function startFlip3Sequence(tgtIdx, fromIdx) {
                const tgt = state.players[tgtIdx];
                tgt.flip3Active = true;
                trackAction('flip3'); // Stats tracking

                // Auto Reaction Flip 3 (Anxiety!)
                showReaction(tgt.id, 'shock');
                bc({ t: 'reaction', who: tgt.id, id: 'shock' });

                // Set Context for queue processing
                state.flip3Context = { from: fromIdx, to: tgtIdx };

                // FIX: Initialize Global Flip3 State
                state.flip3State = { active: true, count: 0, targetIdx: tgtIdx, paused: false };

                sync(); updateGame();

                setTimeout(dealFlip3, 1500);
            }

            // CORE LOGIC: Recursive Flip 3 Deal with Pause support
            function dealFlip3() {
                if (!state.flip3State || !state.flip3State.active) return;
                if (state.flip3State.paused) return; // PAUSED

                // Check Pending (Double check to prevent race)
                if (state.pending) {
                    state.flip3State.paused = true;
                    return;
                }

                const tgtIdx = state.flip3State.targetIdx;
                const tgt = state.players[tgtIdx];

                if (state.flip3State.count < 3 && tgt.st === 'active') {
                    drawCard(tgtIdx, true); // true = isFlip3 context

                    // CHECK PAUSE IMMEDIATELY AFTER DRAW
                    // If drawCard triggered Freeze, state.pending is NOW true.
                    if (state.pending) {
                        state.flip3State.paused = true;
                        // Do NOT increment count? 
                        // Wait, drawCard() already gave the card. The Freeze card counts as 1 of the 3 cards.
                        // Yes, Freeze IS a card.
                        state.flip3State.count++;
                        sync(); updateGame();
                        return; // Stop recursion. Resume will call dealFlip3 again.
                    }

                    state.flip3State.count++;
                    sync(); updateGame();

                    // Check Delay
                    const isAction = state.last && state.last.type === 'action';
                    const delay = isAction ? 3600 : 2200;

                    setTimeout(dealFlip3, delay);
                } else {
                    // Finished or busted
                    state.flip3State.active = false;
                    tgt.flip3Active = false;
                    state.flip3State = null;
                    // Check logic queue via Global function
                    processFlip3Queue();
                }
            }

            function dealLoop() {
                if (!state.dealingPhase) return;
                // FIX: Explicitly pause dealing if an action resolution is pending
                if (state.dealingPaused) return;

                // Block if animation is active
                if (qs('body').classList.contains('animation-blocked')) {
                    setTimeout(dealLoop, 200);
                    return;
                }
                if (state.pending) return;

                if (state.dealIndex >= state.players.length) {
                    // Done Dealing
                    state.dealingPhase = false;
                    // Find first ACTIVE player to start turn (skip frozen/stayed)
                    let startTurn = (state.dealer + 1) % state.players.length;
                    let attempts = 0;
                    while (state.players[startTurn].st !== 'active' && attempts < state.players.length) {
                        startTurn = (startTurn + 1) % state.players.length;
                        attempts++;
                    }
                    state.turn = startTurn;

                    state.globalToast = { id: Date.now(), msg: "Inizia il round!" };
                    sync(); updateGame();
                    return;
                }

                const pIdx = state.turnOrder[state.dealIndex];
                const p = state.players[pIdx];

                // Deal card
                if (p.st === 'active') {
                    drawCard(pIdx);
                    // Synchronous Pending or Flip 3 Sequence
                    if (state.pending || (state.players.some(x => x.flip3Active))) {
                        state.dealIndex++;
                        // Do not schedule recursion. Action resolution will handle it.
                        return;
                    }
                }

                state.dealIndex++;
                // Async Action safeguard (Freeze splash delay ~2.5s)
                const isAction = state.last && state.last.type === 'action';
                const delay = isAction ? 2600 : 900;
                setTimeout(dealLoop, delay);
            }

            function showCardSplash(type, who = null) {
                // BLOCK UI FOR EVERYONE
                qs('body').classList.add('animation-blocked');

                const overlay = document.createElement('div');
                overlay.className = 'action-splash';

                let html = `<div class="card action" style="transform:scale(1.8); box-shadow:0 0 30px rgba(0,0,0,0.5); background: rgba(255,255,255,0.1); backdrop-filter: blur(10px);">
                <img src="${ASSETS[type] || ASSETS.warning}" style="width:80%; height:auto; filter:drop-shadow(0 0 10px rgba(255,255,255,0.5));">
            </div>`;

                if (who && who !== myName) {
                    const prettyNames = { 'freeze': 'Freeze', 'flip3': 'Flip 3', 'second_chance': 'Second Chance' };
                    html += `<div style="color:white; font-size:28px; margin-top:50px; text-shadow:0 2px 10px black; font-weight:800; text-align:center; animation:fadeIn 0.5s 0.3s both; background:rgba(0,0,0,0.4); padding:10px 20px; border-radius:15px; border:1px solid rgba(255,255,255,0.2);">
                    ${who} 
                    <div style="display:flex; align-items:center; justify-content:center; gap:8px; font-size:18px; font-weight:400; opacity:0.9; margin-top:5px;">
                        ha pescato ${prettyNames[type] || type}! 
                        <img src="${ASSETS[type]}" style="height:24px;">
                    </div>
                </div>`;
                }
                overlay.innerHTML = `<div style="display:flex; flex-direction:column; align-items:center; justify-content:center;">${html}</div>`;

                document.body.appendChild(overlay);

                // Animation styles for splash
                overlay.style.position = 'fixed';
                overlay.style.top = '0';
                overlay.style.left = '0';
                overlay.style.width = '100%';
                overlay.style.height = '100%';
                overlay.style.display = 'flex';
                overlay.style.alignItems = 'center';
                overlay.style.justifyContent = 'center';
                overlay.style.background = 'rgba(0,0,0,0.6)';
                overlay.style.zIndex = '5000';
                overlay.style.backdropFilter = 'blur(5px)';
                overlay.style.animation = 'fadeIn 0.3s forwards';

                setTimeout(() => {
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        overlay.remove();
                        qs('body').classList.remove('animation-blocked');
                    }, 300);
                }, 2000); // 2 seconds block
            }

            // Helper for Buttons - reset 3D state
            function resetButton(btn) {
                btn.classList.add('clicked');
                btn.blur(); // Force release of :active/:focus state
                setTimeout(() => btn.classList.remove('clicked'), 150);
            }

            function applyCooldown() {
                const btnHit = qs('#btnHit');
                const btnStay = qs('#btnStay');
                btnHit.classList.add('btn-cooldown');
                btnStay.classList.add('btn-cooldown');
                setTimeout(() => {
                    btnHit.classList.remove('btn-cooldown');
                    btnStay.classList.remove('btn-cooldown');
                }, 1000);
            }

            let lastClickTime = 0;
            qs('#btnHit').onclick = function () {
                if (state.dealingPhase) { showToast("Attendi la distribuzione..."); return; }
                if (Date.now() - lastClickTime < 1000) return; // Rate Limit 1s
                lastClickTime = Date.now();
                resetButton(this);
                applyCooldown();
                isHost ? handleAct(myId, 'hit') : sendHost({ t: 'act', a: 'hit' });
            };
            qs('#btnStay').onclick = function () {
                if (state.dealingPhase) { showToast("Attendi la distribuzione..."); return; }
                if (Date.now() - lastClickTime < 1000) return; // Rate Limit 1s
                lastClickTime = Date.now();
                resetButton(this);
                applyCooldown();
                isHost ? handleAct(myId, 'stay') : sendHost({ t: 'act', a: 'stay' });
            };

            function renderCard(c, isNew = false, p = null) {
                let src = '';
                // Optimization for images - ensure no spaces in path
                const path = 'assets/cards/';

                if (c.type === 'number') src = `${path}number_${c.value}.webp`;
                else if (c.type === 'modifier') src = `${path}modifier_${c.value}.webp`;
                else if (c.type === 'action') src = `${path}action_${c.value}.webp`;
                else if (c.type === 'back' || !src) src = `${path}back.webp`; // Handle back/fallback if needed

                const bustClass = c.isBustCause ? 'bust-cause' : '';
                const newClass = isNew ? 'fly-in' : '';

                // Advanced Animations
                const isBounce = isNew && c.type === 'number' && c.value >= 8;
                const isShiny = c.type === 'action' || (c.type === 'number' && c.value >= 10) || (c.type === 'modifier' && c.value === 'x2'); // Shiny for Actions, high cards, x2

                let extra = '';
                if (isBounce) extra += ' bounce';
                if (isShiny) extra += ' shiny';

                if (c.isBustCause && p && p.bustTime && Date.now() - p.bustTime < 600) extra += ' bust-shake';
                if (p && p.scBurn) {
                    if (c.value === 'second_chance' || c.isBustCause) extra += ' burning';
                }

                return `<img src="${src}" class="card ${c.type} ${bustClass} ${newClass}${extra}" alt="${c.value}">`;
            }
            function drawCard(idx) {
                if (!state.deck.length) {
                    if (state.discards.length) {
                        state.globalToast = { id: Date.now(), msg: "Mescolo gli scarti... 🔀" };
                        state.deck = shuffle([...state.discards]);
                        state.discards = [];
                    } else {
                        endRound(); return;
                    }
                }
                const p = state.players[idx], c = state.deck.pop(); state.last = c;

                // FLIP 3 FIX: If player is in Flip 3 loop, actions don't interrupt
                const isFlip3 = p.flip3Active;

                if (c.type === 'number') {
                    if (p.nums.has(c.value)) {
                        // SECOND CHANCE LOGIC
                        if (p.sc) {
                            // Show the card first!
                            c.isBustCause = true; // Highlight red
                            p.cards.push(c);

                            // Consume SC flag but keep badge for a moment? 
                            // Actually, let's keep p.sc true for a split second so badge shows, then remove.
                            // Wait... if I keep p.sc true, next draw might trigger again? 
                            // No, we are inside the 'bust' branch. We won't draw again immediately.
                            // Logic:

                            SFX.play('bust'); // Play sound to scare them
                            qs('body').classList.add('shake', 'animation-blocked');
                            setTimeout(() => qs('body').classList.remove('shake'), 400);

                            // Show the burn animation STATE
                            p.scBurn = true;

                            // NEW: Splash Hot Face REMOVED as requested, localized only
                            // NEW: Auto Reaction SC Burn
                            showReaction(p.id, 'fire');
                            if (isHost) bc({ t: 'reaction', who: p.id, id: 'fire' });

                            addToHistory(`${p.name} brucia una Second Chance! 🔥`, 'special');

                            sync(); updateGame();

                            // Trigger burn animation is handled by renderCard checking p.scBurn
                            // Just wait for animation to complete
                            setTimeout(() => {
                                // Remove SC card
                                const scIdx = p.cards.findIndex(x => x.type === 'action' && x.value === 'second_chance');
                                if (scIdx > -1) p.cards.splice(scIdx, 1);

                                // Remove bust card
                                const bustIdx = p.cards.indexOf(c);
                                if (bustIdx > -1) p.cards.splice(bustIdx, 1);

                                p.sc = false;
                                p.scBurn = false;

                                state.discards.push({ type: 'action', value: 'second_chance' }, c);

                                SFX.play('action');
                                qs('body').classList.remove('animation-blocked');

                                sync(); updateGame();
                            }, 2500);

                            // We return here? No, we need to sync the 'show card' state first.
                            // But we must NOT set p.st = 'bust'.
                        }
                        else {
                            p.st = 'bust'; p.pts = 0; p.bustTime = Date.now();
                            trackBust(p.id); // Stats tracking
                            SFX.play('bust');

                            // Auto Reaction Bust & Smoke (Real Smoke Effect)
                            spawnSmokeOnPlayer(p.id);
                            // FIX 8: Broadcast smoke to all clients
                            if (isHost) bc({ t: 'smoke', who: p.id });

                            const bustReact = 'bust';
                            showReaction(p.id, bustReact);
                            if (isHost) bc({ t: 'reaction', who: p.id, id: bustReact });

                            p.cards.forEach(card => { if (card.value === c.value && card.type === 'number') card.isBustCause = true; });
                            c.isBustCause = true;
                            p.cards.push(c);

                            if (p.id === myId) {
                                qs('body').classList.add('shake');
                                setTimeout(() => qs('body').classList.remove('shake'), 400);
                            }

                            addToHistory(`${p.name} ha sballato con un ${c.value}! 💥`, 'bust');
                        }
                    } else {
                        p.nums.add(c.value); p.cards.push(c); p.pts = calcPts(p);
                        trackCardDealt(p.id); // Stats tracking
                        if (p.nums.size >= 7) {
                            // FIX 4: Debug log for Flip7 verification
                            console.log(`🎉 FLIP7 triggered for ${p.name}! Unique nums: ${p.nums.size}, Cards in hand: ${p.cards.filter(c => c.type === 'number').length}, Nums Set:`, [...p.nums]);
                            p.st = 'flip7'; p.pts = calcPts(p);
                            trackFlip7(p.id); // Stats tracking
                            SFX.play('flip7');
                            // Only fire if I am this player
                            if (p.id === myId) {
                                fireConfetti('flip7'); // Function logic removed, add inline here or restore?
                                // Restoring inline logic for winner only
                                const duration = 3000;
                                const end = Date.now() + duration;
                                (function frame() {
                                    confetti({ particleCount: 7, angle: 60, spread: 55, origin: { x: 0 }, colors: ['#A78BFA', '#fbbf24'] });
                                    confetti({ particleCount: 7, angle: 120, spread: 55, origin: { x: 1 }, colors: ['#A78BFA', '#fbbf24'] });
                                    if (Date.now() < end) requestAnimationFrame(frame);
                                })();
                            }

                            qs('body').classList.add('flip7-glow');
                            setTimeout(() => qs('body').classList.remove('flip7-glow'), 2000);
                            showCardSplash('star', p.name);
                            if (isHost) bc({ t: 'splash', a: 'star', who: p.name });
                            addToHistory(`${p.name} HA FATTO FLIP 7! 🔥`, 'special');
                            endRound(); return;
                        }
                        if (c.type === 'number') addToHistory(`${p.name} ha pescato ${c.value}`, 'normal');
                    }
                } else if (c.type === 'modifier') {
                    p.mods.push(c); p.cards.push(c); p.pts = calcPts(p);
                    addToHistory(`${p.name} ha pescato modificatore ${c.value}`, 'normal');
                }
                else if (c.type === 'action') {
                    showCardSplash(c.value, p.name); // Trigger splash visually
                    if (isHost) bc({ t: 'splash', a: c.value, who: p.name }); // Broadcast to all
                    SFX.play('action');
                    const actionIcons = { freeze: '❄️ Freeze', flip3: '⚡ Flip 3', second_chance: '❤️ Second Chance' };
                    addToHistory(`${p.name} ha pescato ${actionIcons[c.value] || c.value}!`, 'special');

                    // FIX: Pause dealing if dealing phase and async action
                    if (state.dealingPhase && ['freeze', 'flip3'].includes(c.value)) {
                        state.dealingPaused = true;
                    }

                    // FLIP3 QUEUE LOGIC:
                    // If we are inside a Flip 3 loop, we QUEUE other Flip 3 cards.
                    // Freeze and Second Chance fall through to standard logic (Freeze pauses, SC burns/keeps).
                    if (isFlip3 && c.value === 'flip3') {
                        p.cards.push(c);
                        state.flip3Queue.push({ t: c.value, from: idx, card: c });
                        showToast(`Azione Flip 3 in coda!`);
                        return;
                    }

                    const activeCount = state.players.filter(pl => pl.st === 'active').length;

                    // FLIP3: Drawer draws 3 cards themselves (no targeting)
                    // RULE CHANGE: Action is played on TARGET.
                    if (c.value === 'flip3') {
                        p.cards.push(c);
                        // Determine Target:
                        // If during Initial Deal or alone -> Self
                        if (state.dealingPhase || activeCount <= 1) {
                            startFlip3Sequence(idx, idx);
                        } else {
                            // Choose target with delay for splash
                            setTimeout(() => {
                                state.pending = { t: 'flip3', from: idx };
                                sync(); updateGame();
                                if (idx === state.players.findIndex(p => p.id === myId)) showTgt();
                            }, 2500);
                        }
                        return;
                    }

                    // FREEZE: Choose someone to freeze (if alone, freeze self)
                    if (c.value === 'freeze') {
                        p.cards.push(c);
                        if (activeCount <= 1) {
                            // Freeze self with dramatic sequence
                            setTimeout(() => {
                                if (p.id === myId) showToast("Hai pescato Freeze! ❄️");

                                setTimeout(() => {
                                    if (p.id === myId) showToast("Sei l'ultimo! Ti congeli... 🥶");

                                    setTimeout(() => {
                                        p.frozen = true;
                                        p.st = 'stayed';

                                        if (state.dealingPhase) dealLoop(); // Resume deal
                                        else { nextTurn(); sync(); updateGame(); }
                                    }, 2000);
                                }, 1500);
                            }, 500);

                        } else {
                            // Choose target with delay for splash
                            setTimeout(() => {
                                state.pending = { t: 'freeze', from: idx };
                                sync(); updateGame();
                                if (idx === state.players.findIndex(p => p.id === myId)) showTgt();
                                else if (isHost) {
                                    // If host is not the player, we sync state, client should open modal.
                                    // We need to ensure client opens modal on pending update.
                                    // Currently updateGame doesn't call showTgt automatically.
                                    // We should broadcast a cmd? No, state sync should be enough if updateGame checks it.
                                    // Let's add checkPendingAction() to updateGame if not present.
                                    // Or send specific 'show_tgt' message?
                                    // Actually, handleMsg calls updateGame.
                                    // Let's make sure we call checkPending() in updateGame.
                                    // For now, just sync.
                                }
                            }, 2500);
                        }
                        return;
                    }

                    // SECOND CHANCE: Keep as life, donate if have one
                    if (c.value === 'second_chance') {
                        if (p.sc) {
                            // Already have SC - MUST GIVE AWAY
                            if (activeCount <= 1) {
                                // FIX 1: Alone - discard with BURN ANIMATION (broadcast to all)
                                // Show splash to all explaining why SC burns
                                if (isHost) {
                                    bc({ t: 'sc_burn_alone', who: p.name });
                                }
                                showSCBurnAloneSplash(p.name);

                                // Set burn state for animation
                                p.scBurn = true;
                                p.cards.push(c); // Temporarily add for visual

                                // Fire reaction
                                showReaction(p.id, 'fire');
                                if (isHost) bc({ t: 'reaction', who: p.id, id: 'fire' });

                                addToHistory(`${p.name} scarta Second Chance (ultimo rimasto)! 🔥`, 'special');
                                sync(); updateGame();

                                // After 2s, remove the card
                                setTimeout(() => {
                                    p.scBurn = false;
                                    const scIdx = p.cards.findIndex(x => x.type === 'action' && x.value === 'second_chance' && x !== c);
                                    // Remove the NEW SC (the one just drawn = c)
                                    const newScIdx = p.cards.indexOf(c);
                                    if (newScIdx > -1) p.cards.splice(newScIdx, 1);
                                    state.discards.push(c);
                                    sync(); updateGame();
                                }, 2000);
                            } else {
                                // Donate to someone - Delay for splash
                                setTimeout(() => {
                                    state.pending = { t: 'give_sc', from: idx, card: c };
                                    sync(); updateGame();
                                    if (idx === state.players.findIndex(p => p.id === myId)) showTgt();
                                }, 2500);
                            }
                        } else {
                            // Keep it as extra life
                            p.sc = true;
                            trackSecondChance(p.id); // Stats tracking
                            p.cards.push(c);
                        }
                        // If dealing, we need to resume! 
                        // Wait, if we set pending 'give_sc', deal pauses.
                        // If we just kept it, we need to auto-resume deal if dealingPhase?
                        // drawCard is synchronous usually, but dealLoop waits for it.
                        // Actually dealLoop just calls drawCard then setTimeout.
                        // So if NO pending set, logic continues.
                    }
                }
            }

            // ...

            function resetRound() {
                state.players.forEach(p => {
                    p.cards = []; p.mods = []; p.nums = new Set(); p.pts = 0; p.st = 'active'; p.sc = false;
                    // Reset statuses
                    p.frozen = false; p.flip3Active = false;
                    p.bustTime = 0; // State cleanup
                });
                state.last = null; state.pending = null; state.flip3 = 0;
                localPlayerCardCounts = {}; localAnimatingCards = {};
                // Cleanup visual artifacts (Ghost Skulls)
                document.querySelectorAll('.bust-reaction, .reaction-bubble').forEach(e => e.remove());
            }

            // Duplicate endRound removed - see startRecapSequence below

            function calcPts(p) {
                // 1. Sum number cards only
                let b = p.cards.reduce((s, c) => s + (c.type === 'number' ? c.value : 0), 0);
                // 2. Apply x2 multiplier
                if (p.mods.some(m => m.value === 'x2')) b *= 2;
                // 3. Add +15 Flip7 bonus (after x2, not affected by multiplier)
                if (p.st === 'flip7') b += 15;
                // 4. Add modifier bonuses (+2, +4, +6, etc.)
                p.mods.forEach(m => { if (m.value.startsWith('+')) b += parseInt(m.value.slice(1)); });
                return b;
            }

            // Duplicate listeners removed



            function handleAct(pid, act, tgt) {
                const idx = state.players.findIndex(p => p.id === pid); if (idx === -1) return;
                const p = state.players[idx];
                if (act === 'hit' && idx === state.turn && p.st === 'active') {
                    SFX.play('hit');
                    drawCard(idx);
                    if (state.pending) {
                        const delay = (state.last && state.last.type === 'action') ? 2600 : 0;
                        if (isHost) setTimeout(showTgt, delay);
                    } else if (p.st !== 'active') { if (p.st === 'bust') setTimeout(() => nextTurn(), 3000); else nextTurn(); }
                } else if (act === 'stay' && idx === state.turn) {
                    SFX.play('click');
                    p.st = 'stayed';
                    trackStay(p.id); // Stats tracking
                    addToHistory(`${p.name} si è fermato`, 'normal');
                    // Show Stop reaction with broadcast
                    showReaction(p.id, 'stop');
                    if (isHost) bc({ t: 'reaction', who: p.id, id: 'stop' });
                    nextTurn();
                } else if (act === 'tgt') resAct(tgt);
                sync(); updateGame();
            }

            function showTgt() {
                if (!state.pending) return;
                if (state.players.findIndex(p => p.id === myId) !== state.pending.from) return;
                const tm = qs('#targetModal');

                // Pretty modal titles
                const titles = {
                    'freeze': '❄️ Chi vuoi congelare?',
                    'flip3': '⚡ Chi deve pescare 3 carte?',
                    'give_sc': '❤️ A chi regali Second Chance?'
                };
                qs('#modalTitle').innerText = titles[state.pending.t] || `Scegli bersaglio`;

                qs('#targetButtons').innerHTML = ''; // Clear

                // Gather Candidates
                let candidates = [];
                state.players.forEach((p, i) => {
                    // Must be active
                    if (p.st !== 'active') return;

                    // SC Filter: Cannot give to someone who already has SC (including self)
                    if (state.pending.t === 'give_sc' && (p.sc || p.id === myId)) return;

                    // Freeze/Flip3: Can target self? Rules say yes usually, but UI implies attack.
                    // Current logic allows targeting self if active (unless restricted elsewhere).
                    // Let's keep logic: all active players.

                    candidates.push({ p: p, i: i });
                });

                // SORT: By Total Score Descending (High Risk first), then Round Points
                // If it's 'give_sc', maybe sort by score ascending? (Helping loser). 
                // User requested "Freeze... Ordina per punteggio". We'll use Leaderboard sort (Desc) as default.
                candidates.sort((a, b) => (b.p.tot - a.p.tot) || (b.p.pts - a.p.pts));

                // Determine Highest Score for highlighting
                const maxScore = candidates.length > 0 ? candidates[0].p.tot : 0;

                candidates.forEach(c => {
                    const p = c.p;
                    const i = c.i;
                    const isHighRisk = (p.tot === maxScore && p.tot > 0);

                    const div = document.createElement('div');
                    div.className = 'target-item';
                    if (isHighRisk) div.classList.add('high-risk');

                    // Content
                    div.innerHTML = `
                    <div style="flex:1;">
                        <div style="font-weight:700; font-size:16px; display:flex; align-items:center; gap:6px;">
                            ${p.name}
                            ${isHighRisk ? '<span title="High Score Danger">🔥</span>' : ''}
                        </div>
                        <div style="font-size:12px; opacity:0.8; margin-top:2px;">
                            Round: <strong>${p.pts}</strong> | Tot: <strong>${p.tot}</strong>
                        </div>
                    </div>
                    <div style="font-size:20px; opacity:0.6;">🎯</div>
                `;

                    div.onclick = () => {
                        tm.classList.remove('active');
                        isHost ? handleAct(myId, 'tgt', i) : sendHost({ t: 'act', a: 'tgt', tgt: i });
                    };
                    qs('#targetButtons').appendChild(div);
                });

                tm.classList.add('active');
            }

            function startFlip3Sequence(tgtIdx, fromIdx) {
                const tgt = state.players[tgtIdx];
                tgt.flip3Active = true;
                trackAction('flip3'); // Stats tracking

                // Auto Reaction Flip 3 (Anxiety!)
                showReaction(tgt.id, 'shock');
                bc({ t: 'reaction', who: tgt.id, id: 'shock' });

                // Set Context for queue processing
                state.flip3Context = { from: fromIdx, to: tgtIdx };

                sync(); updateGame();

                let count = 0;
                function flip3Loop() {
                    if (count < 3 && tgt.st === 'active') {
                        drawCard(tgtIdx, true);
                        count++;
                        sync(); updateGame();

                        // Check if last card was Action (triggered 2s splash)
                        const isAction = state.last && state.last.type === 'action';
                        const delay = isAction ? 3600 : 2200;

                        setTimeout(flip3Loop, delay);
                    } else {
                        tgt.flip3Active = false;
                        // Check logic queue via Global function
                        processFlip3Queue();
                    }
                }

                setTimeout(flip3Loop, 1500);
            }

            // Global definition for processing queue and finishing sequence
            function processFlip3Queue() {
                if (state.flip3Queue.length > 0) {
                    const queued = state.flip3Queue.shift();
                    const tgtIdx = state.flip3Context?.to;
                    const tgt = state.players[tgtIdx];

                    showToast(`Risolvo azione accodata: ${queued.t}`);

                    setTimeout(() => {
                        if (queued.t === 'freeze') {
                            const activeC = state.players.filter(p => p.st === 'active').length;
                            if (activeC <= 1) {
                                tgt.frozen = true; tgt.st = 'stayed';
                                setTimeout(finishFlip3Sequence, 1000);
                            } else {
                                state.pending = { t: 'freeze', from: tgtIdx, isQueue: true };
                                showTgt();
                            }
                        } else if (queued.t === 'flip3') {
                            const activeC = state.players.filter(p => p.st === 'active').length;
                            if (activeC <= 1) {
                                startFlip3Sequence(tgtIdx, tgtIdx);
                            } else {
                                state.pending = { t: 'flip3', from: tgtIdx, isQueue: true };
                                showTgt();
                            }
                        }
                    }, 1000);
                } else {
                    finishFlip3Sequence();
                }
            }

            function finishFlip3Sequence() {
                if (state.dealingPhase) {
                    // FIX 3: Toast when resuming dealing
                    if (isHost) bc({ t: 'broadcast_toast', type: 'deal_resume', from: '', target: '' });
                    showToast('🎴 Azione risolta, riprendiamo il dealing!');
                    state.dealingPaused = false; // FIX: Resume dealing
                    dealLoop();
                }
                else {
                    const fromIdx = state.flip3Context?.from;
                    if (fromIdx !== undefined && fromIdx === state.turn && state.players[fromIdx].st === 'active') {
                        showToast(`${state.players[fromIdx].name} continua il turno!`);
                        sync(); updateGame();
                    } else {
                        nextTurn(); sync(); updateGame();
                    }
                }
            }

            // New Async handling for Flip 3 animation in Host
            // New Async handling for Flip 3 animation in Host
            function resAct(tgtIdx) {
                if (!state.pending) return; // Safety check
                const fromIdx = state.pending.from;
                const fromPlayer = state.players[fromIdx];
                const tgt = state.players[tgtIdx], a = state.pending.t;
                const isQueue = state.pending.isQueue;
                state.pending = null; // Clear pending

                if (a === 'freeze') {
                    tgt.frozen = true;
                    tgt.st = 'stayed';
                    trackAction('freeze'); // Stats tracking

                    // Broadcast toast to all
                    if (isHost) {
                        const toastType = (fromIdx === tgtIdx) ? 'freeze_self' : 'freeze';
                        bc({ t: 'broadcast_toast', type: toastType, from: fromPlayer.name, target: tgt.name });
                        showBroadcastToast(toastType, fromPlayer.name, tgt.name);
                    }

                    sync(); updateGame(); // Show frozen state immediately

                    setTimeout(() => {
                        if (state.dealingPhase) {
                            // FIX 3: Toast when resuming dealing after freeze
                            if (isHost) bc({ t: 'broadcast_toast', type: 'deal_resume', from: '', target: '' });
                            showToast('🎴 Azione risolta, riprendiamo il dealing!');
                            state.dealingPaused = false; // FIX: Resume dealing
                            dealLoop();
                        }
                        // FIX: Resume Flip3 Loop if paused (Interruption Logic)
                        else if (state.flip3State && state.flip3State.paused) {
                            state.flip3State.paused = false;
                            dealFlip3();
                        }
                        else if (isQueue) {
                            processFlip3Queue();
                        } else {
                            nextTurn();
                        }
                        sync(); updateGame();
                    }, 2200);
                }
                else if (a === 'give_sc') {
                    tgt.sc = true;
                    trackSecondChance(tgt.id); // Stats tracking
                    tgt.cards.push({ type: 'action', value: 'second_chance' });

                    // Broadcast toast to all
                    if (isHost) {
                        bc({ t: 'broadcast_toast', type: 'give_sc', from: fromPlayer.name, target: tgt.name });
                        showBroadcastToast('give_sc', fromPlayer.name, tgt.name);
                    }

                    sync(); updateGame(); // Show transfer immediately

                    setTimeout(() => {
                        if (state.dealingPhase) {
                            // FIX 3: Toast when resuming dealing after give_sc
                            if (isHost) bc({ t: 'broadcast_toast', type: 'deal_resume', from: '', target: '' });
                            showToast('🎴 Azione risolta, riprendiamo il dealing!');
                            state.dealingPaused = false; // Resume dealing
                            dealLoop();
                        }
                        // FIX: Resume Flip3 Loop if paused
                        else if (state.flip3State && state.flip3State.paused) {
                            state.flip3State.paused = false;
                            dealFlip3();
                        }
                        else {
                            // Continue current logic
                            sync(); updateGame();
                        }
                    }, 2200);
                }
                else if (a === 'flip3') {
                    // Broadcast toast for Flip3
                    if (isHost) {
                        bc({ t: 'broadcast_toast', type: 'flip3', from: fromPlayer.name, target: tgt.name });
                        showBroadcastToast('flip3', fromPlayer.name, tgt.name);
                    }
                    startFlip3Sequence(tgtIdx, state.turn);
                    // startFlip3Sequence handles its own loops and syncs
                }
            }

            function nextTurn() {
                let i = 0; do { state.turn = (state.turn + 1) % state.players.length; i++; } while (state.players[state.turn].st !== 'active' && i < state.players.length);
                if (state.players.every(p => p.st !== 'active')) { endRound(); return; }

                // Global toast for turn start - stored in state for sync to all clients
                const currentPlayer = state.players[state.turn];
                if (currentPlayer) {
                    state.globalToast = { id: Date.now(), msg: `Tocca a: ${currentPlayer.name}!` };
                }

                sync(); updateGame();
            }

            function startRecapSequence() {
                state.phase = 'recap';
                sync(); updateGame();
            }

            function nextRoundCmd() {
                if (!isHost) return;
                state.phase = 'game';
                resetRound(); dealInit();
            }

            function endRound() {
                state.players.forEach(p => {
                    // Force active players to 'stayed' so they bank points (Rule: Flip7 saves everyone active)
                    if (p.st === 'active') p.st = 'stayed';

                    // If SC wasn't used, discard it
                    if (p.sc) {
                        const scIdx = p.cards.findIndex(x => x.type === 'action' && x.value === 'second_chance');
                        if (scIdx > -1) {
                            // Move to discards
                            state.discards.push(p.cards[scIdx]);
                            p.cards.splice(scIdx, 1);
                        }
                        p.sc = false;
                    }

                    if (p.st !== 'bust') p.tot += p.pts;
                    state.discards.push(...p.cards);
                });
                trackRoundEnd(); // Stats tracking
                const w = state.players.filter(p => p.tot >= 200);
                if (w.length >= 1) { // Handle case where multiple pass 200 (though usually 1 turn at a time)
                    state.phase = 'end';
                    sync(); updateGame();
                    return;
                }
                state.round++; state.dealer = (state.dealer + 1) % state.players.length;

                // Deck Persistence: We DO NOT createDeck() here.
                // We just trigger recap, then nextRoundCmd will call resetRound() and dealInit()

                // Trigger Recap
                startRecapSequence();
            }



            function renderHiddenCard() {
                return `<img src="assets/cards/back.webp" class="card back" alt="Back">`;
            }

            function sync() { if (isHost) bc({ t: 'state', s: serState() }); }

            // === SMART RENDER HELPERS ===

            // Render a SINGLE player into a container (clears container first)
            function renderSinglePlayerZone(container, player, state) {
                if (!player) {
                    container.innerHTML = '';
                    return;
                }
                const pIdx = state.players.findIndex(x => x.id === player.id);
                const zoneId = `pzone-${pIdx}`;
                let zone = document.getElementById(zoneId);

                // If zone exists elsewhere, move it here
                if (zone) {
                    container.innerHTML = '';
                    container.appendChild(zone);
                } else {
                    // Create new zone
                    zone = document.createElement('div');
                    zone.id = zoneId;
                    zone.className = 'player-zone';
                    zone.innerHTML = `
                    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                        <span class="p-name" style="font-weight:700; font-size:14px; display:flex; align-items:center; gap:6px;"></span>
                        <div class="p-badges" style="display:flex; align-items: center;">
                            <div class="round-score-glass">0</div>
                        </div>
                    </div>
                    <div class="player-cards"></div>
                    <div class="modifiers-row" style="margin-top:8px; min-height:40px; display:flex; align-items:center; position:relative;">
                        <div class="mods-container" style="flex:1; display:flex; justify-content:center; gap:5px;"></div>
                        <div class="reaction-overlay" style="position:absolute; right:0; display:flex; gap:5px; align-items:center; min-width:60px; height:50px; justify-content:flex-end;"></div>
                    </div>
                    <div class="bust-overlay-container"></div>
                `;
                    container.innerHTML = '';
                    container.appendChild(zone);
                }

                const isMe = player.id === myId;
                const isTurn = pIdx === state.turn;
                updatePlayerZone(zone, player, isMe, isTurn, state);
            }

            // Master layout routing function
            function smartRenderLayout() {
                const myIdx = state.players.findIndex(p => p.id === myId);
                const activeIdx = state.turn;
                const me = state.players[myIdx];
                const activePlayer = state.players[activeIdx];

                // Determine if action is in progress (requires showing target)
                const actionInProgress = state.pending &&
                    (state.pending.t === 'freeze' || state.pending.t === 'flip3' || state.pending.t === 'give_sc');
                const actionFromIdx = actionInProgress ? state.pending.from : null;

                // For Flip3, track the target from flip3Context
                let actionTargetIdx = null;
                if (state.flip3Context && state.flip3Context.tgt !== undefined) {
                    actionTargetIdx = state.flip3Context.tgt;
                }
                // Also check if any player has flip3Active
                const flip3ActivePlayer = state.players.findIndex(p => p.flip3Active);
                if (flip3ActivePlayer >= 0 && flip3ActivePlayer !== myIdx) {
                    actionTargetIdx = flip3ActivePlayer;
                }

                // Track which indices are shown in special zones
                const shownInSpecialZones = new Set();

                // 1. MY HAND → always in #myHandZone
                if (myIdx >= 0 && me) {
                    renderSinglePlayerZone(qs('#myHandZone'), me, state);
                    shownInSpecialZones.add(myIdx);
                } else {
                    qs('#myHandZone').innerHTML = '';
                }

                // 2. ACTIVE PLAYER ZONE (under deck) → shows current turn player IF not me
                const activeZone = qs('#activePlayerZone');
                if (activeIdx !== myIdx && activePlayer) {
                    renderSinglePlayerZone(activeZone, activePlayer, state);
                    shownInSpecialZones.add(activeIdx);
                } else {
                    activeZone.innerHTML = '';
                }

                // 3. ACTION TARGET ZONE → shows during Freeze/Flip3 when target is not me and not already shown
                const targetZone = qs('#actionTargetZone');
                if (actionTargetIdx !== null && actionTargetIdx !== myIdx && !shownInSpecialZones.has(actionTargetIdx)) {
                    targetZone.style.display = 'block';
                    renderSinglePlayerZone(targetZone, state.players[actionTargetIdx], state);
                    shownInSpecialZones.add(actionTargetIdx);
                } else {
                    targetZone.style.display = 'none';
                    targetZone.innerHTML = '';
                }

                // 4. OTHER PLAYERS → everyone not in special zones
                const otherPlayers = state.players.filter((_, i) => !shownInSpecialZones.has(i));
                smartRenderPlayers(qs('#playersArea'), otherPlayers, false, myId, state.turn, state);
            }

            function smartRenderPlayers(container, players, isMeGlobal, myIdGlobal, turnGlobal, stateGlobal) {
                players.forEach((p, idxList) => {
                    const originalIdx = stateGlobal.players.findIndex(x => x.id === p.id);
                    const zoneId = `pzone-${originalIdx}`;
                    let zone = document.getElementById(zoneId);

                    if (!zone) {
                        zone = document.createElement('div');
                        zone.id = zoneId;
                        zone.className = `player-zone`;
                        zone.innerHTML = `
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                            <span class="p-name" style="font-weight:700; font-size:14px; display:flex; align-items:center; gap:6px;"></span>
                            <div class="p-badges" style="display:flex; align-items: center;">
                                <div class="round-score-glass">0</div>
                            </div>
                        </div>
                        <div class="player-cards"></div>
                        <div class="modifiers-row" style="margin-top:8px; min-height:40px; display:flex; align-items:center; position:relative;">
                            <div class="mods-container" style="flex:1; display:flex; justify-content:center; gap:5px;"></div>
                            <div class="reaction-overlay" style="position:absolute; right:0; display:flex; gap:5px; align-items:center; min-width:60px; height:50px; justify-content:flex-end;"></div>
                        </div>
                        <div class="bust-overlay-container"></div>
                    `;
                    }
                    container.appendChild(zone);
                    updatePlayerZone(zone, p, p.id === myIdGlobal, originalIdx === turnGlobal, stateGlobal);
                });

                // Remove detached zones
                Array.from(container.children).forEach(child => {
                    // If child is not in players list (by checking if we just appended it?)
                    // Since we appended all current players, they are at the end.
                    // Any child not touched/moved is at the beginning?
                    // Actually if I move node A, it leaves its old spot.
                    // So all valid nodes are moved to end.
                    // If there were extra nodes (Z), they remain at start.
                    // But container.children changes live.
                    // So if we have 5 children, and we append 2 existing ones.
                    // Those 2 move to index 3, 4?
                    // No, node is removed from old pos and added to new.
                    // So if Z, A, B.
                    // Append A -> Z, B, A.
                    // Append B -> Z, A, B.
                    // Z remains at 0.
                    // So we remove children from 0 to (count - players.length).
                    while (container.children.length > players.length) {
                        container.firstChild.remove();
                    }
                });
            }

            function updatePlayerZone(zone, p, isMe, isTurn, state) {
                // === Animation Tracking ===
                if (!localPlayerCardCounts[p.id]) localPlayerCardCounts[p.id] = { nums: 0, mods: 0 };
                if (!localAnimatingCards[p.id]) localAnimatingCards[p.id] = { nums: {}, mods: {} };

                const numCards = p.cards.filter(c => c.type === 'number');
                const modCards = p.cards.filter(c => c.type === 'modifier' || (c.type === 'action' && c.value === 'second_chance'));

                if (numCards.length > localPlayerCardCounts[p.id].nums) {
                    for (let k = localPlayerCardCounts[p.id].nums; k < numCards.length; k++) {
                        localAnimatingCards[p.id].nums[k] = Date.now();
                    }
                }
                if (modCards.length > localPlayerCardCounts[p.id].mods) {
                    for (let k = localPlayerCardCounts[p.id].mods; k < modCards.length; k++) {
                        localAnimatingCards[p.id].mods[k] = Date.now();
                    }
                }
                localPlayerCardCounts[p.id] = { nums: numCards.length, mods: modCards.length };
                // ==========================

                const numCount = numCards.length;
                const isMeZone = isMe;
                // Note: p.id === myId is used in original class logic for 'my-zone'
                const finalZoneClass = `player-zone ${isTurn && p.st === 'active' ? 'active-turn' : ''} ${p.st === 'bust' ? 'bust' : ''} ${p.st === 'stayed' ? 'stayed' : ''} ${p.frozen ? 'frozen' : ''} ${isMeZone ? 'my-zone' : ''} ${p.flip3Active ? 'flip3' : ''} ${p.sc ? 'bonus-sc' : ''}`;

                if (zone.className !== finalZoneClass) zone.className = finalZoneClass;

                const nameEl = zone.querySelector('.p-name');
                const suffix = isMe ? ' (Tu)' : '';
                const dealerIcon = p.id === state.dealer ? `<img src="${ASSETS.crown}" style="height:16px;" title="Dealer">` : '';
                const nameHtml = `${p.name} ${suffix} ${dealerIcon}`;
                if (nameEl.innerHTML !== nameHtml) nameEl.innerHTML = nameHtml;
                nameEl.style.fontSize = isMe ? '16px' : '14px';

                const scoreEl = zone.querySelector('.round-score-glass');
                if (scoreEl.innerText != p.pts) scoreEl.innerText = p.pts;



                smartUpdateCards(zone.querySelector('.player-cards'), numCards, p, isMe, 'nums');
                smartUpdateCards(zone.querySelector('.mods-container'), modCards, p, isMe, 'mods');

                const rOv = zone.querySelector('.reaction-overlay');
                const ovHtml = `
                ${p.sc ? `<img src="${ASSETS.sc}" style="height:40px; filter:drop-shadow(0 0 5px red); animation:pulse 1.5s infinite;" title="Second Chance">` : ''}
                ${p.frozen ? `<img src="${ASSETS.frozen}" style="height:40px; filter:drop-shadow(0 0 5px cyan);" title="Congelato">` : ''}
                ${p.flip3Active ? `<img src="${ASSETS.lightning}" style="height:40px; filter:drop-shadow(0 0 5px yellow);" title="Flip 3">` : ''}
                ${(p.st === 'stayed' && !p.frozen) ? `<img src="${ASSETS.stop}" style="height:40px; filter:drop-shadow(0 0 5px green);" title="Stop">` : ''}
                ${(p.st !== 'bust' && numCount === 6) ? `<img src="${ASSETS.fear}" style="height:40px; filter:drop-shadow(0 0 5px orange); animation:pulse 0.5s infinite;" title="-1 Card!">` : ''}
            `.trim();
                if (rOv.innerHTML !== ovHtml) rOv.innerHTML = ovHtml;

                const bCont = zone.querySelector('.bust-overlay-container');
                const showBust = p.st === 'bust' && Date.now() - (p.bustTime || 0) < 2000;
                if (showBust) {
                    if (!bCont.firstChild) {
                        // FIX 7: APNGs on sides of BUST text for symmetric dramatic layout
                        const bustEmojis = [
                            `${FLUENT_BASE}/Smilies/Skull.png`,
                            `${FLUENT_BASE}/Smilies/Loudly%20Crying%20Face.png`,
                            `${FLUENT_BASE}/Smilies/Exploding%20Head.png`
                        ];
                        const emoji = bustEmojis[Math.floor(Math.random() * bustEmojis.length)];
                        bCont.innerHTML = `
                        <div class="bust-overlay" style="gap: 15px;">
                            <img src="${emoji}" style="height:50px; filter:drop-shadow(0 0 10px rgba(244,63,94,0.8));">
                            <span style="color:#FF6B35; font-size:42px; font-weight:900; text-shadow: 0 0 30px rgba(255,107,53,0.8); animation: shake 0.3s infinite;">BUST!</span>
                            <img src="${emoji}" style="height:50px; filter:drop-shadow(0 0 10px rgba(244,63,94,0.8));">
                        </div>
                    `;
                    }
                } else {
                    if (bCont.firstChild) bCont.innerHTML = '';
                }
            }

            function smartUpdateCards(container, cards, p, isMe, typeStr) {
                if (!localPlayerCardCounts[p.id]) localPlayerCardCounts[p.id] = { nums: 0, mods: 0 };
                if (!localAnimatingCards[p.id]) localAnimatingCards[p.id] = { nums: {}, mods: {} };

                let totalSlots = cards.length;
                if (isMe && typeStr === 'nums') totalSlots = Math.max(7, cards.length);

                const children = Array.from(container.children);

                for (let i = 0; i < totalSlots; i++) {
                    const card = (i < cards.length) ? cards[i] : null;
                    let child = children[i];

                    if (!child) {
                        const temp = document.createElement('div');
                        if (card) {
                            const animTime = localAnimatingCards[p.id][typeStr][i];
                            const isAnimating = animTime && (Date.now() - animTime < 800);
                            temp.innerHTML = renderCard(card, isAnimating, p);
                        } else {
                            temp.innerHTML = '<div class="card-placeholder"></div>';
                        }
                        container.appendChild(temp.firstChild);
                        continue;
                    }

                    if (!card) {
                        if (!child.classList.contains('card-placeholder')) {
                            const temp = document.createElement('div');
                            temp.innerHTML = '<div class="card-placeholder"></div>';
                            container.replaceChild(temp.firstChild, child);
                        }
                    } else {
                        const animTime = localAnimatingCards[p.id][typeStr][i];
                        const isAnimating = animTime && (Date.now() - animTime < 800);

                        if (child.classList.contains('card-placeholder')) {
                            const temp = document.createElement('div');
                            temp.innerHTML = renderCard(card, isAnimating, p);
                            container.replaceChild(temp.firstChild, child);
                            continue;
                        }

                        const path = 'assets/cards/';
                        let src = '';
                        if (card.type === 'number') src = `${path}number_${card.value}.webp`;
                        else if (card.type === 'modifier') src = `${path}modifier_${card.value}.webp`;
                        else if (card.type === 'action') src = `${path}action_${card.value}.webp`;
                        else src = `${path}back.webp`;

                        if (child.src && !child.src.includes(src)) child.src = src;

                        const bustClass = card.isBustCause ? 'bust-cause' : '';
                        const newClass = isAnimating ? 'fly-in' : '';
                        const isBounce = isAnimating && card.type === 'number' && card.value >= 8;
                        const isShiny = card.type === 'action' || (card.type === 'number' && card.value >= 10) || (card.type === 'modifier' && card.value === 'x2');
                        let extra = '';
                        if (isBounce) extra += ' bounce';
                        if (isShiny) extra += ' shiny';
                        if (card.isBustCause && p && p.bustTime && Date.now() - p.bustTime < 600) extra += ' bust-shake';
                        if (p && p.scBurn && (card.value === 'second_chance' || card.isBustCause)) extra += ' burning';

                        const finalClass = `card ${card.type} ${bustClass} ${newClass}${extra}`;
                        if (child.className !== finalClass) child.className = finalClass;
                    }
                }
                while (container.children.length > totalSlots) {
                    container.lastChild.remove();
                }
            }

            function updateGame() {
                // Recap Overlay Logic
                const ro = qs('#recapOverlay');
                if (state.phase === 'recap') {
                    if (!ro.classList.contains('active') || ro.getAttribute('data-round') != state.round) {
                        ro.setAttribute('data-round', state.round);
                        const sortedRound = [...state.players].sort((a, b) => b.pts - a.pts);
                        const tableHtml = `
                        <div class="recap-card glass" style="width:95%; max-width:450px; padding:20px; animation: scaleIn 0.5s;">
                            <h2 style="text-align:center; margin-bottom:15px; color:#fbbf24; font-size:24px;">Fine Round ${state.round - 1}</h2>
                            <table class="recap-table">
                                <thead><tr><th style="color:rgba(255,255,255,0.6)">Giocatore</th><th style="text-align:center">Round</th><th style="text-align:right">Totale</th></tr></thead>
                                <tbody>
                                    ${sortedRound.map((p, i) => `
                                    <tr style="border-bottom:1px solid rgba(255,255,255,0.1); height:40px;">
                                        <td style="display:flex; align-items:center; gap:10px;">
                                            <span style="font-weight:bold; color:${p.st === 'bust' ? '#ef4444' : 'white'}">${p.name}</span>
                                            ${p.st === 'bust' ? '💥' : ''} ${i === 0 && p.st !== 'bust' ? '🏆' : ''}
                                        </td>
                                        <td style="text-align:center; font-weight:bold; color:${p.st === 'bust' ? '#ef4444' : '#fbbf24'}">${p.pts > 0 ? '+' : ''}${p.pts}</td>
                                        <td style="text-align:right; font-weight:bold;">${p.tot}</td>
                                    </tr>
                                    `).join('')}
                                </tbody>
                            </table>

                        <button class="btn" style="width:100%; margin-top:20px;" onclick="isHost ? nextRoundCmd() : null" ${!isHost ? 'disabled style="opacity:0.5; cursor:default"' : ''}>
                            ${isHost ? 'Prossimo Round ➡️' : 'Attendi Host...'}
                        </button>
                        </div >
                        `;
                        ro.innerHTML = tableHtml;
                        ro.classList.add('active');
                    }
                } else {
                    ro.classList.remove('active');
                    ro.removeAttribute('data-round');
                }

                // Flip7 Celebration Sync - All players see it when someone gets Flip 7!
                const flip7Player = state.players.find(p => p.st === 'flip7');
                const f7o = qs('#flip7Overlay');
                if (flip7Player && f7o) {
                    if (f7o.style.display !== 'flex') {
                        f7o.querySelector('.flip7-winner-name').innerText = flip7Player.name;
                        f7o.style.display = 'flex';
                        SFX.play('flip7');
                        fireConfetti('flip7');
                        // Auto-hide after 3 seconds
                        setTimeout(() => { f7o.style.display = 'none'; }, 3000);
                    }
                }

                // End Game Screen - All players see it when state.phase === 'end'
                if (state.phase === 'end') {
                    const ego = qs('#endGameOverlay');
                    if (ego.style.display !== 'flex') {
                        // Find winner and sort leaderboard
                        const winner = state.players.find(p => p.tot >= 200);
                        const sortedPlayers = [...state.players].sort((a, b) => b.tot - a.tot);
                        const amIWinner = winner && winner.id === myId;

                        // Status message based on win/loss
                        if (amIWinner) {
                            const duration = 3000;
                            const end = Date.now() + duration;
                            (function frame() {
                                confetti({ particleCount: 7, angle: 60, spread: 55, origin: { x: 0 }, colors: ['#A78BFA', '#fbbf24'] });
                                confetti({ particleCount: 7, angle: 120, spread: 55, origin: { x: 1 }, colors: ['#A78BFA', '#fbbf24'] });
                                if (Date.now() < end) requestAnimationFrame(frame);
                            })();
                        }

                        const statusHtml = amIWinner ? `
                        <div style="font-size:60px; margin-bottom:10px;">👑</div>
                        <h1 style="font-size:42px; margin:0; background:linear-gradient(135deg, #fbbf24, #f59e0b, #eab308); -webkit-background-clip:text; -webkit-text-fill-color:transparent; text-shadow: 0 0 40px rgba(251, 191, 36, 0.5);">VITTORIA!</h1>
                        <p style="color:rgba(255,255,255,0.7); margin:10px 0;">Hai raggiunto ${winner.tot} punti!</p>
                    ` : `
                        <div style="font-size:50px; margin-bottom:10px; filter:grayscale(100%);">😔</div>
                        <h1 style="font-size:36px; margin:0; color:#888;">SCONFITTA</h1>
                        <p style="color:rgba(255,255,255,0.5); margin:10px 0;">${winner.name} ha vinto la partita</p>
                    `;
                        qs('#endGameStatus').innerHTML = statusHtml;

                        // Leaderboard
                        const medals = ['🥇', '🥈', '🥉'];
                        const leaderboardHtml = `
                        <h3 style="text-align:center; margin:0 0 15px; color:white; font-size:18px;">📊 Classifica Finale</h3>
                            ${sortedPlayers.map((p, i) => {
                            const isWinner = p.tot >= 200;
                            const isMe = p.id === myId;
                            return `
                                <div style="display:flex; justify-content:space-between; align-items:center; padding:12px 15px; margin:8px 0; border-radius:10px; 
                                    background:${isWinner ? 'linear-gradient(135deg, rgba(251,191,36,0.3), rgba(245,158,11,0.2))' : 'rgba(255,255,255,0.05)'}; 
                                    border:1px solid ${isWinner ? 'rgba(251,191,36,0.5)' : 'rgba(255,255,255,0.1)'};
                                    ${isWinner ? 'box-shadow: 0 0 20px rgba(251,191,36,0.3);' : ''}">
                                    <div style="display:flex; align-items:center; gap:10px;">
                                        <span style="font-size:24px;">${medals[i] || `#${i + 1}`}</span>
                                        <span style="font-weight:${isWinner ? '700' : '500'}; color:${isWinner ? '#fbbf24' : 'white'};">
                                            ${p.name}${isMe ? ' (Tu)' : ''}
                                        </span>
                                    </div>
                                    <span style="font-size:20px; font-weight:700; color:${isWinner ? '#fbbf24' : '#A78BFA'};">${p.tot}</span>
                                </div>
                            `;
                        }).join('')
                            }
                    `;
                        qs('#endGameLeaderboard').innerHTML = leaderboardHtml;

                        const restartBtn = qs('#btnRestartGame');
                        if (restartBtn) {
                            if (!isHost) {
                                restartBtn.innerText = "Aspettando l'host...";
                                restartBtn.disabled = true;
                                restartBtn.style.opacity = 0.5;
                            } else {
                                restartBtn.innerText = "🔄 Nuova Partita";
                                restartBtn.disabled = false;
                                restartBtn.style.opacity = 1;
                            }
                        }

                        ego.style.display = 'flex';

                        // Render end-game stats charts
                        const statsContainer = qs('#endgameStatsContainer');
                        if (statsContainer) renderEndgameStats(statsContainer);

                        // Effects only for winner
                        if (amIWinner) {
                            SFX.play('win');
                            fireConfetti('win');
                        } else {
                            SFX.play('bust');
                        }
                    }
                    return; // Stop further updates when game ended
                }

                // Show header game status during game
                const hgs = qs('#headerGameStatus');
                if (hgs) hgs.style.display = 'flex';

                qs('#turnName').innerText = state.players[state.turn]?.name || '-';
                qs('#roundNum').innerText = state.round;
                qs('#deckCount').innerText = state.deck.length;

                // Update deck layer visibility based on remaining cards
                const layers = document.querySelectorAll('#deckLayers .deck-layer');
                if (layers.length) {
                    const remaining = state.deck.length;
                    const maxCards = 54; // Full deck size
                    const ratio = remaining / maxCards;
                    // Show 1-3 layers based on remaining cards
                    layers[0].style.opacity = ratio > 0.3 ? 1 : 0; // Bottom layer
                    layers[1].style.opacity = ratio > 0.15 ? 1 : 0; // Middle layer
                    layers[2].style.opacity = remaining > 0 ? 1 : 0.3; // Top layer (always somewhat visible)
                }

                // Global Toast - visible to all clients
                if (state.globalToast && state.globalToast.id > localLastToastId) {
                    showToast(state.globalToast.msg);
                    localLastToastId = state.globalToast.id;
                }

                // Personal Score Update
                const meP = state.players.find(p => p.id === myId);
                if (meP && qs('#personalTot')) qs('#personalTot').innerText = meP.tot;

                // SIDEBAR UPDATES
                // 1. Leaderboard
                const sortedLeaderboard = [...state.players].sort((a, b) => b.tot - a.tot);
                const lbHtml = sortedLeaderboard.map((p, i) => {
                    const isWinner = p.tot >= 200;

                    // Rank Styling
                    let rankClass = '';
                    let rankTextStyle = '';
                    let medalImg = '';

                    if (i === 0) {
                        rankClass = 'rank-1';
                        rankTextStyle = 'rank-text-1';
                        medalImg = `<img src="${FLUENT_BASE}/Activities/1st%20Place%20Medal.png" style="height:24px; margin-right:8px;">`;
                    } else if (i === 1) {
                        rankClass = 'rank-2';
                        rankTextStyle = 'rank-text-2';
                        medalImg = `<img src="${FLUENT_BASE}/Activities/2nd%20Place%20Medal.png" style="height:24px; margin-right:8px;">`;
                    } else if (i === 2) {
                        rankClass = 'rank-3';
                        rankTextStyle = 'rank-text-3';
                        medalImg = `<img src="${FLUENT_BASE}/Activities/3rd%20Place%20Medal.png" style="height:24px; margin-right:8px;">`;
                    }

                    return `<div class="leaderboard-row ${p.id === myId ? 'me' : ''} ${rankClass}" style="${isWinner ? 'color:#fbbf24; font-weight:bold' : ''}">
                    <div style="display:flex; align-items:center;">
                        ${medalImg}
                        <span class="${rankTextStyle}">${i + 1}. ${p.name} ${p.id === myId ? '(Tu)' : ''}</span>
                        ${isWinner ? `<img src="${ASSETS.crown}" style="height:20px; margin-left:6px;">` : ''}
                    </div>
                    <span class="${rankTextStyle}" style="font-weight:bold; font-size:16px;">${p.tot}</span>
                </div>`;
                }).join('');
                qs('#sidebarLeaderboardContent').innerHTML = lbHtml;

                // 2. History
                const historyHtml = state.history ? state.history.map(h => {
                    const isSpecial = h.type === 'special';
                    const isBust = h.type === 'bust';

                    let text = h.t;
                    let iconSrc = '';

                    // Base Style with Flexbox
                    let style = 'padding:10px 12px; margin-bottom:8px; border-radius:12px; font-size:13px; backdrop-filter:blur(5px); display:flex; align-items:center; gap:10px; line-height:1.4;';

                    // Theme & Icon Logic
                    if (text.includes('Freeze') || text.includes('❄️')) {
                        iconSrc = ASSETS.snowflake;
                        style += 'background:rgba(56,189,248,0.15); border:1px solid rgba(56,189,248,0.3); color:#fff;'; // Blue
                        text = text.replace(/❄️/g, '').trim();
                    }
                    else if (text.includes('Flip 3') || text.includes('⚡')) {
                        iconSrc = ASSETS.lightning;
                        style += 'background:rgba(251,191,36,0.15); border:1px solid rgba(251,191,36,0.3); color:#fff;'; // Amber
                        text = text.replace(/⚡/g, '').trim();
                    }
                    else if (text.includes('Second Chance') || text.includes('❤️')) {
                        const heartIcon = ASSETS.sc || ASSETS.heart || 'https://raw.githubusercontent.com/Tarikul-Islam-Anik/Animated-Fluent-Emojis/master/Emojis/Smilies/Red%20Heart.png';
                        iconSrc = heartIcon;
                        style += 'background:rgba(239,68,68,0.15); border:1px solid rgba(239,68,68,0.3); color:#fff;'; // Red
                        text = text.replace(/❤️/g, '').trim();
                    }
                    else if (isBust || text.includes('sballato') || text.includes('💥')) {
                        iconSrc = `${FLUENT_BASE}/Smilies/Bomb.png`; // Bomb Icon
                        style += 'background:rgba(239,68,68,0.2); border:1px solid rgba(239,68,68,0.4); color:#fff; box-shadow:0 0 15px rgba(239,68,68,0.4); animation: pulseRed 2s infinite;';
                        text = text.replace(/💥/g, '').trim();
                    }
                    else if (text.includes('🔥')) {
                        iconSrc = ASSETS.fire || `${FLUENT_BASE}/Travel%20and%20places/Fire.png`;
                        style += 'background:rgba(249,115,22,0.15); border:1px solid rgba(249,115,22,0.3); color:#fff;';
                        text = text.replace(/🔥/g, '').trim();
                    }
                    else {
                        style += 'background:rgba(255,255,255,0.05); border:1px solid rgba(255,255,255,0.1); color:rgba(255,255,255,0.8);';
                    }

                    const imgHtml = iconSrc ? `<img src="${iconSrc}" style="width:28px; height:28px; object-fit:contain; flex-shrink:0; filter:drop-shadow(0 2px 4px rgba(0,0,0,0.3));">` : '';

                    return `<div class="history-item" style="${style}">
                    ${imgHtml}
                    <span>${text}</span>
                </div>`;
                }).join('') : '';
                qs('#sidebarHistoryContent').innerHTML = historyHtml || '<div style="text-align:center; padding:20px; color:var(--text-secondary); font-style:italic">Nessuna azione ancora...</div>';

                // DYNAMIC DECK DEPTH
                const deckEl = qs('.deck');
                if (deckEl) {
                    const depth = Math.min(12, Math.ceil(state.deck.length / 4)); // 1px depth per 4 cards
                    const solidShadow = `0 ${depth}px 0 #5b21b6`;
                    const softShadow = `0 ${depth + 10}px 20px rgba(0, 0, 0, 0.3)`;
                    deckEl.style.boxShadow = `${solidShadow}, ${softShadow} `;
                    deckEl.style.transform = `translateY(-${depth}px)`; // Move up as it grows down to keep center relative
                    deckEl.style.transition = 'all 0.3s ease';
                }

                // Check for pending actions to show modal (for clients)
                if (state.pending && state.pending.from === state.players.findIndex(p => p.id === myId)) {
                    showTgt();
                }

                // Remove old scoreboard updates
                // qs('#scoreRows').innerHTML = ...

                // Use new dynamic layout routing
                smartRenderLayout();

                const meIdx = state.players.findIndex(p => p.id === myId);
                const me = state.players[meIdx];
                const canAct = meIdx === state.turn && me?.st === 'active';
                qs('#btnHit').disabled = !canAct || state.pending; qs('#btnStay').disabled = !canAct || state.pending;
                if (state.pending?.from === meIdx) showTgt();

                // Enable Reaction Button if game is active
                if (state.phase === 'game') {
                    qs('#btnReact').disabled = false;
                    qs('#btnStats').disabled = false;
                } else {
                    qs('#btnReact').disabled = true;
                    qs('#btnStats').disabled = true;
                }

                // GEOMETRY-BASED FLY-IN ANIMATION
                requestAnimationFrame(() => {
                    const flyCards = document.querySelectorAll('.card.fly-in');
                    if (flyCards.length === 0) return;

                    // Find the deck element (visible in UI)
                    const deckEl = document.querySelector('.deck');
                    if (!deckEl) return;

                    const deckRect = deckEl.getBoundingClientRect();
                    const deckCenterX = deckRect.left + deckRect.width / 2;
                    const deckCenterY = deckRect.top + deckRect.height / 2;

                    flyCards.forEach(card => {
                        // Check if we already set values to avoid resetting animation
                        if (card.style.getPropertyValue('--tx')) return;

                        // Calculate target position (current position because it's rendered in place)
                        const cardRect = card.getBoundingClientRect();
                        const cardCenterX = cardRect.left + cardRect.width / 2;
                        const cardCenterY = cardRect.top + cardRect.height / 2;

                        // Vector from Deck to Card
                        // We want: Initial = Deck. Final = Card.
                        // Transform Translate is relative to current position.
                        // If we want it to START at Deck, we need to translate by (Deck - Card).
                        const tx = deckCenterX - cardCenterX;
                        const ty = deckCenterY - cardCenterY;

                        card.style.setProperty('--tx', `${tx}px`);
                        card.style.setProperty('--ty', `${ty}px`);

                        // Unpause animation now that variables are set
                        card.style.animationPlayState = 'running';
                    });
                });
            }

            function showRoom() {
                qs('#hostControls').style.display = 'none';
                qs('#roomInfo').style.display = 'block';
                updateRoomLinkInfo();
                updateLobby();
            }

            function updateRoomLinkInfo() {
                const url = location.href;
                qs('#roomLink').innerText = url;
                qs('#roomLink').href = url;
                qs('#qrcode').innerHTML = '';
                new QRCode(qs('#qrcode'), { text: url, width: 128, height: 128 });
            }

            window.copyRoomLink = () => { navigator.clipboard.writeText(location.href); showToast('Link copiato!'); };

            function updateLobby() {
                qs('#roomInfo').style.display = 'block';
                if (qs('#qrcode').innerHTML === '') updateRoomLinkInfo();
                if (!isHost) qs('.room-link').style.display = 'block';
                qs('#playersList').innerHTML = state.players.map((p, i) => `<div class="player-item ${i === 0 ? 'host' : ''}">${p.name}${p.id === myId ? ' (Tu)' : ''} ${i === 0 ? '👑' : ''}</div>`).join('');

                const statusMsg = isHost ? "In attesa di partecipanti..." : "In attesa che l'host avvii la partita...";
                qs('#lobbyStatusMsg').innerText = statusMsg;

                if (isHost && state.players.length >= 2) qs('#btnStartGame').style.display = 'inline-block';
                else qs('#btnStartGame').style.display = 'none';
            }



            // Logic for Room Code
            qs('#btnShowJoin').onclick = () => {
                qs('#btnCreateRoom').style.display = 'none';
                qs('#btnShowJoin').style.display = 'none';
                qs('#joinCodeArea').style.display = 'block';
                qs('#roomCodeInput').focus();
            };

            qs('#roomCodeInput').oninput = (e) => {
                const val = e.target.value.trim().toUpperCase();
                if (val.length > 0) {
                    const newHash = `flip7 - ${val} `;
                    if (location.hash !== '#' + newHash) {
                        history.replaceState(null, null, `#${newHash} `);
                    }
                    roomId = newHash;
                } else {
                    history.replaceState(null, null, ' ');
                    roomId = null;
                }
            };

            function handleHashChange() {
                const h = location.hash.slice(1);
                if (h?.startsWith('flip7-')) {
                    // If arriving via link or pasting URL
                    const code = h.split('-')[1];
                    qs('#roomCodeInput').value = code || '';

                    qs('#btnCreateRoom').style.display = 'none';
                    qs('#btnShowJoin').style.display = 'none';
                    qs('#joinCodeArea').style.display = 'block';

                    qs('.lobby h2').innerText = "Unisciti alla partita";
                    qs('#nickname').focus();
                    roomId = h;
                    if (window.isCreatingRoom) {
                        showToast('✅ Stanza creata!');
                        window.isCreatingRoom = false;
                    } else {
                        showToast('🔗 Codice stanza rilevato!');
                    }
                }
            }

            const cardImages = {};
            const assets = [
                'back', 'action_flip3', 'action_freeze', 'action_second_chance',
                'modifier_+2', 'modifier_+4', 'modifier_+6', 'modifier_+8', 'modifier_+10', 'modifier_x2',
                'number_0', 'number_1', 'number_3', 'number_4', 'number_5', 'number_6', 'number_7', 'number_8', 'number_9', 'number_10', 'number_11', 'number_12'
            ];

            function preloadImages() {
                assets.forEach(name => {
                    const img = new Image();
                    img.src = `assets/cards/${name}.webp`; //NON MODIFICARE QUESTA RIGA!
                    cardImages[name] = img;
                });
            }

            window.onload = () => {
                preloadImages();
                handleHashChange();
            };
            window.onhashchange = handleHashChange;

            function showToast(msg) {
                const t = qs('#customToast');
                t.innerHTML = msg;
                t.classList.add('active');
                setTimeout(() => t.classList.remove('active'), 3000);
            }

            // Broadcast Toast for action announcements (visible to ALL players)
            function showBroadcastToast(type, fromName, targetName = null) {
                const configs = {
                    freeze: { icon: '❄️', msg: `${fromName} congela ${targetName}!`, cls: 'freeze' },
                    freeze_self: { icon: '❄️', msg: `${fromName} è l'ultimo rimasto, viene congelato!`, cls: 'freeze' },
                    flip3: { icon: '⚡', msg: `${fromName} fa pescare 3 carte a ${targetName}!`, cls: 'flip3' },
                    give_sc: { icon: '❤️', msg: `${fromName} dona Second Chance a ${targetName}!`, cls: 'second-chance' },
                    deal_resume: { icon: '🎴', msg: 'Azione risolta, riprendiamo il dealing!', cls: 'freeze' }
                };
                const cfg = configs[type];
                if (!cfg) return;

                const toast = document.createElement('div');
                toast.className = `broadcast-toast ${cfg.cls}`;
                toast.innerHTML = `<span style="font-size:32px;">${cfg.icon}</span><span>${cfg.msg}</span>`;
                document.body.appendChild(toast);

                setTimeout(() => {
                    toast.style.animation = 'toastSlideOut 0.3s ease-in forwards';
                    setTimeout(() => toast.remove(), 300);
                }, 2800);
            }

            // FIX 1: Splashscreen for SC burn when alone (broadcast to all)
            function showSCBurnAloneSplash(playerName) {
                const splash = qs('#cardSplash');
                const isMe = state.players.find(p => p.name === playerName)?.id === myId;
                const title = isMe ? 'Hai già una Second Chance!' : `${playerName} ha già Second Chance!`;
                splash.innerHTML = `
                <div class="splash-title second_chance" style="font-size: 24px;">${title}</div>
                <div class="splash-card">
                    <img src="assets/cards/action_second_chance.webp" style="width:100%; height:100%; object-fit:contain; border-radius:10px; animation: burnCard 2s forwards;">
                </div>
                <div style="color: #ff6b35; font-size: 16px; margin-top: 10px;">Ultimo rimasto - La carta brucia! 🔥</div>
            `;
                splash.classList.add('active');
                setTimeout(() => splash.classList.remove('active'), 2000);
            }

            // FIX 2: Personalized splashscreen - shows WHO drew the action card
            function showCardSplash(cardValue, whoName = null) {
                const names = { freeze: 'FREEZE!', flip3: 'FLIP THREE!', second_chance: 'SECOND CHANCE!' };
                const splash = qs('#cardSplash');

                // Determine if this is me or another player
                const isMe = whoName && state.players.find(p => p.name === whoName)?.id === myId;
                const whoText = isMe ? 'Hai pescato' : (whoName ? `${whoName} ha pescato` : 'Pescata');

                splash.innerHTML = `
                <div class="splash-title ${cardValue}">${names[cardValue] || cardValue.toUpperCase()}</div>
                <div class="splash-card">
                    <img src="assets/cards/action_${cardValue}.webp" style="width:100%; height:100%; object-fit:contain; border-radius:10px;">
                </div>
                <div style="color: white; font-size: 18px; margin-top: 12px; font-weight: 600; text-shadow: 0 2px 8px rgba(0,0,0,0.5);">
                    ${whoText} ${names[cardValue] || cardValue}!
                </div>
            `;
                splash.classList.add('active');
                setTimeout(() => splash.classList.remove('active'), 2000);
            }

            // PWA INSTALL LOGIC
            let deferredPrompt;

            // Wrap in load event to ensure HTML is parsed
            window.addEventListener('load', () => {
                const installBanner = document.getElementById('installBanner');
                if (!installBanner) return;

                // Check if already installed (Standalone mode)
                const isStandalone = window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;

                // Hide banner if already installed
                if (!isStandalone) {
                    // Android / Desktop - Capture event
                    window.addEventListener('beforeinstallprompt', (e) => {
                        e.preventDefault();
                        deferredPrompt = e;
                        // Show banner after short delay
                        setTimeout(() => installBanner.classList.add('visible'), 3000);
                    });

                    // iOS Detection - Show banner anyway if iOS
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                    if (isIOS) {
                        setTimeout(() => installBanner.classList.add('visible'), 3000);
                    }
                }
            });

            function installApp() {
                const installBanner = document.getElementById('installBanner');
                // Android / Desktop Native Prompt
                if (deferredPrompt) {
                    deferredPrompt.prompt();
                    deferredPrompt.userChoice.then((choiceResult) => {
                        if (choiceResult.outcome === 'accepted') {
                            installBanner.classList.remove('visible');
                        }
                        deferredPrompt = null;
                    });
                }
                // iOS Instructions
                else {
                    const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
                    if (isIOS) {
                        document.getElementById('iosPwaModal').classList.add('active');
                    } else {
                        showToast("Premi l'icona di installazione nella barra del browser!");
                    }
                }
            }
        </script>
        <div id="customToast"></div>
        <div id="recapOverlay"></div>
        <div id="cardSplash"></div>
        <div id="flip7Overlay"
            style="display:none; position:fixed; top:0; left:0; right:0; bottom:0; background:rgba(0,0,0,0.85); z-index:2500; align-items:center; justify-content:center; flex-direction:column; backdrop-filter:blur(20px);">
            <!-- FIX 5: Using official Flip7 Logo instead of emoji -->
            <img src="assets/Flip7 Logo.webp" alt="Flip7"
                style="height:120px; animation: bounce 0.5s ease infinite alternate, pulseGlow 1s ease infinite; filter: drop-shadow(0 0 30px rgba(251, 191, 36, 0.8));">
            <h1
                style="font-size:56px; margin:20px 0; background:linear-gradient(135deg, #fbbf24, #f59e0b, #eab308); -webkit-background-clip:text; background-clip:text; -webkit-text-fill-color:transparent; animation: pulseGlow 0.5s ease infinite alternate;">
                FLIP 7!</h1>
            <p class="flip7-winner-name" style="font-size:28px; color:white; margin-bottom:10px; font-weight:700;"></p>
            <p style="font-size:18px; color:rgba(255,255,255,0.7);">+15 Punti Bonus! 🎉</p>
        </div>
        <!-- PWA Install Banner -->
        <div id="installBanner" class="install-banner">
            <div class="close-install" onclick="document.getElementById('installBanner').classList.remove('visible');">✕
            </div>
            <img src="assets/Flip7%20Logo.webp" class="install-img" alt="Flip 7 Icon">
            <div class="install-text">
                <strong>Installa Flip 7</strong>
                Esperienza schermo intero! 🚀
            </div>
            <button class="install-btn" onclick="installApp()">Installa</button>
        </div>

        <!-- iOS Install Guide Modal -->
        <div id="iosPwaModal" onclick="this.classList.remove('active')">
            <div class="ios-pwa-content" onclick="event.stopPropagation()">
                <div style="font-size: 50px; margin-bottom: 20px;">📱</div>
                <h2 style="color:white; margin-bottom: 15px;">Installa Flip 7 su iOS</h2>
                <p style="color:rgba(255,255,255,0.7); line-height: 1.6; margin-bottom: 30px;">
                    Per un'esperienza di gioco senza distrazioni e a schermo intero:
                </p>

                <div
                    style="text-align: left; background: rgba(255,255,255,0.05); padding: 20px; border-radius: 15px; margin-bottom: 30px;">
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 15px;">
                        <div
                            style="background: var(--primary); width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; flex-shrink: 0;">
                            1</div>
                        <span style="color: white; font-size: 15px;">Premi il pulsante <strong>Condividi</strong> (<img
                                src="https://em-content.zobj.net/source/apple/391/share-button_1f4e4.png"
                                style="height: 20px; vertical-align: middle;">) nella barra di Safari</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 15px;">
                        <div
                            style="background: var(--primary); width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 800; flex-shrink: 0;">
                            2</div>
                        <span style="color: white; font-size: 15px;">Seleziona <strong>Aggiungi alla schermata
                                Home</strong>
                            (<img src="https://em-content.zobj.net/source/apple/391/plus_2b.png"
                                style="height: 18px; vertical-align: middle;">)</span>
                    </div>
                </div>

                <button class="btn" style="width: 100%;"
                    onclick="document.getElementById('iosPwaModal').classList.remove('active')">Capito!</button>
            </div>
        </div>
</body>

</html>